<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>AI Assistant</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Figtree:wght@400;500;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js"></script>
<style>
:root {
  --bg: #0a0a0f;
  --sidebar-bg: #14141a;
  --card-border: rgba(255, 255, 255, 0.08);
  --text-primary: rgba(255, 255, 255, 0.95);
  --text-secondary: rgba(255, 255, 255, 0.6);
  --accent: #6366f1;
  --accent-hover: #818cf8;
  --msg-user: #6366f1;
  --msg-assistant: rgba(255, 255, 255, 0.08);
  --hover: rgba(255, 255, 255, 0.05);
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: 'Figtree', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  height: 100vh;
  height: 100dvh;
  background: var(--bg);
  color: var(--text-primary);
  display: flex;
  overflow: hidden;
}

/* Sidebar */
.sidebar {
  width: 260px;
  background: var(--sidebar-bg);
  border-right: 1px solid var(--card-border);
  display: flex;
  flex-direction: column;
  flex-shrink: 0;
  transition: margin-left 0.3s ease;
}
.sidebar.collapsed { margin-left: -260px; }

.sidebar-header {
  padding: 16px;
  border-bottom: 1px solid var(--card-border);
  display: flex;
  gap: 8px;
}
.sidebar-header button {
  flex: 1;
  padding: 10px;
  font-family: inherit;
  font-size: 0.85em;
  font-weight: 600;
  background: var(--accent);
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition: background 0.2s;
}
.sidebar-header button:hover { background: var(--accent-hover); }

.sidebar-search {
  padding: 8px 8px 0;
}
.sidebar-search input {
  width: 100%;
  padding: 8px 10px;
  font-family: inherit;
  font-size: 0.82em;
  background: var(--hover);
  border: 1px solid var(--card-border);
  border-radius: 6px;
  color: var(--text-primary);
  outline: none;
  transition: border-color 0.2s;
}
.sidebar-search input:focus { border-color: var(--accent); }
.sidebar-search input::placeholder { color: var(--text-secondary); }

.conv-list {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
}

.conv-item {
  padding: 10px 12px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 0.85em;
  color: var(--text-secondary);
  transition: all 0.2s;
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 2px;
}
.conv-item:hover { background: var(--hover); }
.conv-item.active { background: rgba(99, 102, 241, 0.15); color: var(--text-primary); }

.conv-item .conv-title {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.conv-item .conv-delete {
  display: none;
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  font-size: 14px;
  padding: 0 4px;
  flex-shrink: 0;
}
.conv-item:hover .conv-delete { display: block; }
.conv-item .conv-delete:hover { color: #ef4444; }

/* Main Area */
.main {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-width: 0;
  position: relative;
}

/* Header Toolbar */
.toolbar {
  height: 50px;
  padding: 0 16px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-bottom: 1px solid var(--card-border);
  background: var(--sidebar-bg);
  flex-shrink: 0;
}
.toolbar-left { display: flex; align-items: center; gap: 12px; }
.toolbar-toggle {
  background: none;
  border: none;
  color: var(--text-primary);
  font-size: 18px;
  cursor: pointer;
  padding: 4px;
}
.toolbar-title {
  font-size: 0.95em;
  font-weight: 600;
}
.toolbar-right { display: flex; align-items: center; gap: 8px; }
.toolbar-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  font-size: 16px;
  cursor: pointer;
  padding: 6px;
  border-radius: 6px;
  transition: all 0.2s;
  position: relative;
}
.toolbar-btn:hover { color: var(--text-primary); background: var(--hover); }

/* Toolbar more menu */
.toolbar-more {
  position: relative;
}
.toolbar-menu {
  display: none;
  position: absolute;
  top: 100%;
  right: 0;
  margin-top: 4px;
  background: var(--sidebar-bg);
  border: 1px solid var(--card-border);
  border-radius: 8px;
  min-width: 180px;
  z-index: 100;
  box-shadow: 0 4px 16px rgba(0,0,0,0.4);
  overflow: hidden;
}
.toolbar-menu.open { display: block; }
.toolbar-menu button {
  display: flex;
  align-items: center;
  gap: 8px;
  width: 100%;
  padding: 10px 14px;
  font-family: inherit;
  font-size: 0.85em;
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  text-align: left;
}
.toolbar-menu button:hover { background: var(--hover); color: var(--text-primary); }

.theme-flash {
  position: absolute;
  bottom: -22px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 0.7em;
  white-space: nowrap;
  background: var(--sidebar-bg);
  border: 1px solid var(--card-border);
  padding: 2px 6px;
  border-radius: 4px;
  pointer-events: none;
  animation: flashFade 1.5s ease forwards;
  z-index: 10;
}
@keyframes flashFade { 0% { opacity: 1; } 70% { opacity: 1; } 100% { opacity: 0; } }

/* Messages Area */
.messages-area {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 12px;
}
.chat-placeholder {
  color: var(--text-secondary);
  font-size: 1em;
  text-align: center;
  padding: 60px 20px;
  margin: auto;
}

/* Message styles */
.msg-wrapper { display: flex; flex-direction: column; position: relative; }
.msg-wrapper.user { align-self: flex-end; max-width: 75%; }
.msg-wrapper.assistant { align-self: flex-start; max-width: 75%; }

.msg-bubble {
  padding: 12px 16px;
  border-radius: 16px;
  font-size: 0.95em;
  line-height: 1.6;
  word-wrap: break-word;
}
.msg-bubble.user {
  background: var(--msg-user);
  color: white;
  border-bottom-right-radius: 4px;
}
.msg-bubble.assistant {
  background: var(--msg-assistant);
  color: var(--text-primary);
  border-bottom-left-radius: 4px;
}

/* Markdown in messages */
.msg-bubble pre { background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px; overflow-x: auto; margin: 6px 0; white-space: pre; }
.msg-bubble code { background: rgba(255,255,255,0.1); padding: 2px 5px; border-radius: 4px; font-family: 'Menlo', 'Monaco', 'Consolas', monospace; font-size: 0.9em; }
.msg-bubble pre code { background: none; padding: 0; }
.msg-bubble blockquote { border-left: 3px solid var(--accent); padding-left: 10px; color: var(--text-secondary); margin: 6px 0; }
.msg-bubble a { color: var(--accent-hover); text-decoration: underline; }
.msg-bubble ul, .msg-bubble ol { padding-left: 20px; margin: 4px 0; }
.msg-bubble h1, .msg-bubble h2, .msg-bubble h3, .msg-bubble h4 { margin: 8px 0 4px; font-weight: 600; }
.msg-bubble h1 { font-size: 1.2em; }
.msg-bubble h2 { font-size: 1.1em; }
.msg-bubble h3 { font-size: 1.05em; }
.msg-bubble table { border-collapse: collapse; margin: 6px 0; font-size: 0.95em; }
.msg-bubble th, .msg-bubble td { border: 1px solid var(--card-border); padding: 4px 8px; }
.msg-bubble th { background: var(--hover); }
.msg-bubble img.chat-inline-img { max-width: min(300px, 100%); max-height: 300px; border-radius: 8px; margin-top: 6px; display: block; }

/* Code copy button */
.code-block-wrapper { position: relative; }
.code-copy-btn {
  position: absolute;
  top: 6px;
  right: 6px;
  padding: 3px 8px;
  font-size: 0.75em;
  font-family: inherit;
  background: rgba(255,255,255,0.15);
  border: none;
  border-radius: 4px;
  color: var(--text-secondary);
  cursor: pointer;
  opacity: 0;
  transition: opacity 0.2s, background 0.2s;
}
.code-block-wrapper:hover .code-copy-btn { opacity: 1; }
.code-copy-btn:hover { background: rgba(255,255,255,0.25); color: var(--text-primary); }

/* Message actions */
.msg-actions {
  display: none;
  gap: 4px;
  margin-top: 4px;
}
.msg-wrapper:hover .msg-actions { display: flex; }
.msg-action-btn {
  padding: 3px 8px;
  font-size: 0.75em;
  font-family: inherit;
  background: var(--hover);
  border: 1px solid var(--card-border);
  border-radius: 4px;
  color: var(--text-secondary);
  cursor: pointer;
  transition: all 0.2s;
}
.msg-action-btn:hover { background: rgba(255,255,255,0.1); color: var(--text-primary); }

/* Message edit mode */
.msg-edit-textarea {
  width: 100%;
  min-height: 60px;
  padding: 10px;
  font-family: inherit;
  font-size: 0.95em;
  background: var(--hover);
  border: 1px solid var(--accent);
  border-radius: 8px;
  color: var(--text-primary);
  resize: vertical;
  outline: none;
  margin-top: 8px;
  line-height: 1.5;
}
.msg-edit-actions {
  display: flex;
  gap: 8px;
  margin-top: 8px;
}
.msg-edit-actions button {
  padding: 6px 14px;
  border: none;
  border-radius: 6px;
  font-family: inherit;
  font-size: 0.8em;
  cursor: pointer;
  transition: all 0.2s;
}
.msg-edit-save { background: var(--accent); color: white; }
.msg-edit-save:hover { background: var(--accent-hover); }
.msg-edit-cancel { background: var(--hover); color: var(--text-primary); border: 1px solid var(--card-border) !important; }
.msg-edit-cancel:hover { background: rgba(255,255,255,0.1); }

/* Swipe controls */
.swipe-controls { display: none; flex-direction: row; align-items: center; gap: 8px; margin-top: 6px; font-size: 0.8em; color: var(--text-secondary); }
.msg-wrapper.assistant:last-child .swipe-controls.has-swipes { display: flex; }
.swipe-controls button { background: var(--hover); border: none; color: var(--text-secondary); padding: 3px 10px; border-radius: 6px; cursor: pointer; }
.swipe-controls button:hover { background: rgba(255,255,255,0.1); color: var(--text-primary); }
.swipe-controls button:disabled { opacity: 0.3; cursor: not-allowed; }

/* Regenerate button */
.regen-btn { display: none; background: var(--hover); border: none; color: var(--text-secondary); padding: 6px 14px; border-radius: 8px; cursor: pointer; font-size: 0.8em; margin-top: 6px; transition: all 0.2s; align-self: flex-start; font-family: inherit; }
.msg-wrapper.assistant:last-child .regen-btn { display: inline-block; }
.regen-btn:hover { background: rgba(255,255,255,0.1); color: var(--text-primary); }

/* Input Footer */
.input-area {
  padding: 12px 16px 16px;
  border-top: 1px solid var(--card-border);
  background: var(--sidebar-bg);
}
.image-preview { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 8px; }
.image-preview:empty { display: none; }
.img-thumb { position: relative; width: 56px; height: 56px; border-radius: 8px; overflow: hidden; flex-shrink: 0; }
.img-thumb img { width: 100%; height: 100%; object-fit: cover; }
.img-thumb .remove-thumb { position: absolute; top: -2px; right: -2px; background: #ef4444; border: none; color: white; width: 18px; height: 18px; border-radius: 50%; font-size: 11px; cursor: pointer; display: flex; align-items: center; justify-content: center; }

.input-row { display: flex; gap: 8px; align-items: flex-end; }
.input-row textarea {
  flex: 1;
  padding: 10px 14px;
  font-size: 0.95em;
  font-family: inherit;
  background: var(--hover);
  border: 2px solid rgba(255, 255, 255, 0.1);
  border-radius: 12px;
  color: var(--text-primary);
  outline: none;
  resize: none;
  min-height: 44px;
  max-height: 150px;
  line-height: 1.4;
  transition: border-color 0.3s;
}
.input-row textarea:focus { border-color: var(--accent); }
.input-row textarea::placeholder { color: var(--text-secondary); }

.input-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  font-size: 18px;
  cursor: pointer;
  padding: 8px;
  flex-shrink: 0;
  transition: color 0.2s;
}
.input-btn:hover { color: var(--text-primary); }
.input-btn.recording { color: #ef4444; animation: voicePulse 1s ease-in-out infinite; }
@keyframes voicePulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

.send-btn {
  padding: 10px 20px;
  font-size: 0.9em;
  font-family: inherit;
  font-weight: 600;
  background: var(--accent);
  color: white;
  border: none;
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.2s;
  flex-shrink: 0;
}
.send-btn:hover { background: var(--accent-hover); }
.send-btn:disabled { opacity: 0.5; cursor: not-allowed; }
.send-btn.streaming { background: #ef4444; }
.send-btn.streaming:hover { background: #dc2626; }

.token-info { font-size: 0.75em; color: var(--text-secondary); text-align: right; margin-top: 6px; min-height: 1em; }

/* Modals */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  backdrop-filter: blur(4px);
}
.modal-overlay.open { display: flex; }

.modal {
  background: var(--sidebar-bg);
  border: 1px solid var(--card-border);
  border-radius: 16px;
  padding: 28px;
  width: 90%;
  max-width: 520px;
  max-height: 90vh;
  max-height: 90dvh;
  overflow-y: auto;
}
.modal h2 {
  font-size: 1.2em;
  margin-bottom: 20px;
}
.modal label {
  display: block;
  font-size: 0.85em;
  color: var(--text-secondary);
  margin-bottom: 4px;
}
.modal input, .modal textarea, .modal select {
  width: 100%;
  padding: 12px;
  font-family: inherit;
  font-size: 0.9em;
  background: var(--hover);
  border: 1px solid var(--card-border);
  border-radius: 8px;
  color: var(--text-primary);
  margin-bottom: 14px;
  outline: none;
  transition: border-color 0.2s;
}
.modal input:focus, .modal textarea:focus, .modal select:focus { border-color: var(--accent); }
.modal textarea { resize: vertical; min-height: 60px; max-height: 120px; }
.modal select option { background: var(--sidebar-bg); color: var(--text-primary); }

.modal .modal-actions {
  display: flex;
  gap: 10px;
  margin-top: 8px;
}
.modal .btn {
  flex: 1;
  padding: 12px;
  font-family: inherit;
  font-size: 0.9em;
  font-weight: 600;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s;
}
.modal .btn-primary { background: var(--accent); color: white; }
.modal .btn-primary:hover { background: var(--accent-hover); }
.modal .btn-secondary { background: var(--hover); color: var(--text-primary); }
.modal .btn-secondary:hover { background: rgba(255,255,255,0.1); }

.modal .invalid { border-color: #ef4444 !important; }

/* Model selector row */
.model-selector-row {
  display: flex;
  gap: 8px;
  margin-bottom: 4px;
}
.model-selector-row select {
  flex: 1;
  margin-bottom: 0;
}
.model-refresh-btn {
  padding: 8px 12px;
  background: var(--hover);
  border: 1px solid var(--card-border);
  border-radius: 8px;
  color: var(--text-primary);
  cursor: pointer;
  font-size: 16px;
  transition: background 0.2s;
  flex-shrink: 0;
}
.model-refresh-btn:hover { background: rgba(255,255,255,0.1); }

/* Theme color pickers */
.theme-colors {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
  margin-bottom: 14px;
}
.theme-color-item {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 0.8em;
  color: var(--text-secondary);
}
.theme-color-item input[type="color"] {
  width: 32px;
  height: 28px;
  border: 1px solid var(--card-border);
  border-radius: 4px;
  background: none;
  cursor: pointer;
  padding: 0;
}

/* Section dividers in settings */
.modal-section {
  font-size: 0.8em;
  font-weight: 600;
  color: var(--accent);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin: 18px 0 10px;
  padding-bottom: 4px;
  border-bottom: 1px solid var(--card-border);
}
.modal-section:first-of-type { margin-top: 0; }

@media (hover: none) {
  .msg-wrapper .msg-actions { display: flex; }
  .code-block-wrapper .code-copy-btn { opacity: 1; }
  .code-block-wrapper .code-download-btn { opacity: 1; }
  .conv-item .conv-delete { display: block; }
}

/* Responsive */
@media (max-width: 768px) {
  .sidebar { position: fixed; left: 0; top: 0; bottom: 0; z-index: 500; }
  .sidebar.collapsed { margin-left: -260px; }
  .msg-wrapper.user, .msg-wrapper.assistant { max-width: 95%; }
  .toolbar-title { font-size: 0.85em; }
  .input-area { padding: 8px 12px 12px; }
  .messages-area { padding: 12px; }
  .sidebar-overlay.open { display: block; }
  .toolbar { padding-top: env(safe-area-inset-top); }
  .input-area { padding-bottom: max(12px, env(safe-area-inset-bottom)); }
  .sidebar { padding-top: env(safe-area-inset-top); padding-bottom: env(safe-area-inset-bottom); }
  .toolbar-btn { padding: 10px; min-width: 44px; min-height: 44px; display: flex; align-items: center; justify-content: center; }
  .toolbar-toggle { min-width: 44px; min-height: 44px; display: flex; align-items: center; justify-content: center; }
  .input-btn { min-width: 44px; min-height: 44px; display: flex; align-items: center; justify-content: center; }
  .img-thumb .remove-thumb { width: 28px; height: 28px; font-size: 14px; top: -4px; right: -4px; }
  .msg-action-btn { padding: 8px 12px; font-size: 0.8em; min-height: 36px; }
  .swipe-controls button { padding: 8px 14px; min-height: 36px; }
  .regen-btn { padding: 10px 16px; min-height: 36px; }
  .code-copy-btn { padding: 8px 12px; font-size: 0.8em; min-height: 36px; }
  .conv-item .conv-delete { padding: 8px; min-width: 36px; min-height: 36px; display: flex; align-items: center; justify-content: center; }
  .input-row textarea, .modal input, .modal textarea, .modal select { font-size: 16px; }
}

/* Mobile sidebar overlay */
.sidebar-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.4);
  z-index: 499;
}

/* Tool use blocks (web search) */
.tool-use-block {
  margin-bottom: 8px;
  border-radius: 8px;
  background: var(--hover);
  overflow: hidden;
  font-size: 0.85em;
}
.tool-use-header {
  padding: 8px 12px;
  cursor: pointer;
  color: var(--text-secondary);
  display: flex;
  align-items: center;
  gap: 6px;
  user-select: none;
}
.tool-use-header:hover { color: var(--text-primary); }
.tool-use-results {
  display: none;
  padding: 4px 12px 8px;
  border-top: 1px solid var(--card-border);
}
.tool-use-results.open { display: block; }
.tool-use-result { margin: 4px 0; }
.tool-use-result a {
  color: var(--accent);
  text-decoration: none;
  font-size: 0.85em;
}
.tool-use-result a:hover { text-decoration: underline; }
.tool-use-result .tool-result-url {
  color: var(--text-secondary);
  font-size: 0.8em;
  display: block;
}

/* Settings toggle row */
.toggle-row {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 0.9em;
  color: var(--text-primary);
  margin-bottom: 10px;
  cursor: pointer;
}
.toggle-row input[type="checkbox"] {
  width: auto;
  margin: 0;
  padding: 0;
  cursor: pointer;
}
.toggle-hint {
  color: var(--text-secondary);
  font-size: 0.8em;
  margin-left: auto;
}

/* Message fade-in animation */
@keyframes msgFadeIn { from { opacity: 0; transform: translateY(12px); } to { opacity: 1; transform: translateY(0); } }
.msg-new { animation: msgFadeIn 0.3s ease forwards; }

/* Animated typing indicator */
.typing-dots { display: inline-flex; align-items: center; gap: 4px; padding: 4px 0; }
.typing-dots span { width: 6px; height: 6px; border-radius: 50%; background: var(--text-secondary); animation: typingBounce 1.2s ease-in-out infinite; }
.typing-dots span:nth-child(2) { animation-delay: 0.15s; }
.typing-dots span:nth-child(3) { animation-delay: 0.3s; }
@keyframes typingBounce { 0%, 60%, 100% { transform: translateY(0); opacity: 0.4; } 30% { transform: translateY(-6px); opacity: 1; } }

/* Scroll-to-bottom FAB */
.scroll-fab {
  position: absolute;
  bottom: 12px;
  right: 20px;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: var(--accent);
  color: white;
  border: none;
  cursor: pointer;
  font-size: 18px;
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 10;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  transition: background 0.2s, transform 0.2s;
}
.scroll-fab:hover { background: var(--accent-hover); transform: scale(1.1); }
.scroll-fab.visible { display: flex; }

/* Toast notifications */
.toast-container { position: fixed; top: 16px; right: 16px; z-index: 2000; display: flex; flex-direction: column; gap: 8px; pointer-events: none; }
.toast {
  padding: 10px 16px;
  border-radius: 8px;
  font-size: 0.85em;
  font-family: inherit;
  color: white;
  pointer-events: auto;
  animation: toastIn 0.3s ease forwards;
  max-width: 340px;
  word-break: break-word;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}
.toast.info { background: var(--accent); }
.toast.error { background: #ef4444; }
.toast.success { background: #22c55e; }
.toast.removing { animation: toastOut 0.3s ease forwards; }
@keyframes toastIn { from { opacity: 0; transform: translateX(40px); } to { opacity: 1; transform: translateX(0); } }
@keyframes toastOut { from { opacity: 1; transform: translateX(0); } to { opacity: 0; transform: translateX(40px); } }

/* Thinking/reasoning blocks */
.thinking-block { margin-bottom: 8px; border-radius: 8px; background: var(--hover); overflow: hidden; font-size: 0.85em; }
.thinking-header { padding: 8px 12px; cursor: pointer; color: var(--text-secondary); display: flex; align-items: center; gap: 6px; user-select: none; }
.thinking-header:hover { color: var(--text-primary); }
.thinking-content { display: none; padding: 4px 12px 8px; border-top: 1px solid var(--card-border); white-space: pre-wrap; color: var(--text-secondary); max-height: 300px; overflow-y: auto; }
.thinking-content.open { display: block; }

/* Line numbers in code blocks */
.code-line { counter-increment: code-line; display: block; }
.code-line::before { content: counter(code-line); display: inline-block; width: 2.5em; margin-right: 0.8em; text-align: right; color: var(--text-secondary); opacity: 0.4; user-select: none; -webkit-user-select: none; font-size: 0.85em; }
pre.has-line-numbers { counter-reset: code-line; }

/* Code download button */
.code-download-btn {
  position: absolute;
  top: 6px;
  right: 56px;
  padding: 3px 8px;
  font-size: 0.75em;
  font-family: inherit;
  background: rgba(255,255,255,0.15);
  border: none;
  border-radius: 4px;
  color: var(--text-secondary);
  cursor: pointer;
  opacity: 0;
  transition: opacity 0.2s, background 0.2s;
}
.code-block-wrapper:hover .code-download-btn { opacity: 1; }
.code-download-btn:hover { background: rgba(255,255,255,0.25); color: var(--text-primary); }

/* Mermaid container */
.mermaid-container { margin: 6px 0; overflow-x: auto; }
.mermaid-container svg { max-width: 100%; }

/* Pin button on conversations */
.conv-pin { display: none; background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 12px; padding: 0 4px; flex-shrink: 0; opacity: 0.6; }
.conv-item:hover .conv-pin { display: block; }
.conv-pin.pinned { display: block; opacity: 1; color: var(--accent); }
.conv-pin:hover { opacity: 1; }

/* Date group headers */
.conv-group-header { font-size: 0.7em; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.05em; padding: 10px 12px 4px; }

/* Drag-drop reorder */
.conv-item.dragging { opacity: 0.4; }
.conv-item.drag-over { border-top: 2px solid var(--accent); }

/* Branch controls */
.branch-controls { display: none; flex-direction: row; align-items: center; gap: 8px; margin-top: 6px; font-size: 0.8em; color: var(--text-secondary); }
.branch-controls.has-branches { display: flex; }
.branch-controls button { background: var(--hover); border: none; color: var(--text-secondary); padding: 3px 10px; border-radius: 6px; cursor: pointer; }
.branch-controls button:hover { background: rgba(255,255,255,0.1); color: var(--text-primary); }
.branch-controls button:disabled { opacity: 0.3; cursor: not-allowed; }

/* Chat search bar */
.chat-search-bar {
  display: none;
  padding: 6px 16px;
  background: var(--sidebar-bg);
  border-bottom: 1px solid var(--card-border);
  gap: 8px;
  align-items: center;
}
.chat-search-bar.open { display: flex; }
.chat-search-bar input {
  flex: 1;
  padding: 6px 10px;
  font-family: inherit;
  font-size: 0.85em;
  background: var(--hover);
  border: 1px solid var(--card-border);
  border-radius: 6px;
  color: var(--text-primary);
  outline: none;
}
.chat-search-bar input:focus { border-color: var(--accent); }
.chat-search-bar button {
  background: var(--hover);
  border: none;
  color: var(--text-secondary);
  padding: 4px 8px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.85em;
}
.chat-search-bar button:hover { color: var(--text-primary); }
.chat-search-bar .search-count { font-size: 0.8em; color: var(--text-secondary); white-space: nowrap; }
.search-highlight { background: rgba(255, 200, 50, 0.3); border-radius: 2px; }
.search-highlight.active { background: rgba(255, 200, 50, 0.6); }

/* Spoiler tags */
.spoiler {
  background: var(--text-primary);
  color: transparent;
  border-radius: 4px;
  padding: 1px 4px;
  cursor: pointer;
  transition: all 0.2s;
  user-select: none;
}
.spoiler.revealed {
  background: var(--hover);
  color: var(--text-primary);
  user-select: auto;
}

/* @model mentions */
.model-override-badge {
  display: none;
  align-items: center;
  gap: 6px;
  padding: 4px 10px;
  margin-bottom: 6px;
  font-size: 0.8em;
  background: var(--hover);
  border: 1px solid var(--accent);
  border-radius: 8px;
  color: var(--accent);
  width: fit-content;
}
.model-override-badge.visible { display: inline-flex; }
.model-override-badge button {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  font-size: 14px;
  padding: 0;
  line-height: 1;
}
.model-override-badge button:hover { color: var(--text-primary); }
.mention-dropdown {
  position: absolute;
  bottom: 100%;
  left: 50px;
  background: var(--sidebar-bg);
  border: 1px solid var(--card-border);
  border-radius: 8px;
  max-height: 200px;
  overflow-y: auto;
  display: none;
  z-index: 100;
  min-width: 200px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}
.mention-dropdown.open { display: block; }
.mention-item {
  padding: 8px 12px;
  font-size: 0.85em;
  cursor: pointer;
  color: var(--text-secondary);
}
.mention-item:hover, .mention-item.active { background: var(--hover); color: var(--text-primary); }

@media (hover: none) {
  .scroll-fab { width: 44px; height: 44px; }
  .conv-pin { display: block; }
  .branch-controls button { padding: 8px 14px; min-height: 36px; }
}

/* Character card avatar in sidebar */
.conv-avatar {
  width: 22px;
  height: 22px;
  border-radius: 50%;
  object-fit: cover;
  flex-shrink: 0;
  margin-right: 4px;
}

/* Character info popup */
.char-info-popup {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: var(--sidebar-bg);
  border: 1px solid var(--card-border);
  border-radius: 16px;
  padding: 24px;
  max-width: 480px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
  z-index: 1100;
  box-shadow: 0 8px 32px rgba(0,0,0,0.5);
}
.char-info-popup h3 { margin-bottom: 12px; }
.char-info-popup .char-info-field { margin-bottom: 10px; font-size: 0.85em; }
.char-info-popup .char-info-label { color: var(--accent); font-weight: 600; font-size: 0.8em; text-transform: uppercase; letter-spacing: 0.03em; margin-bottom: 2px; }
.char-info-popup .char-info-value { color: var(--text-secondary); white-space: pre-wrap; }
.char-info-popup .char-info-avatar { width: 64px; height: 64px; border-radius: 50%; object-fit: cover; margin-bottom: 12px; }
.char-info-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 1099;
}
@media (max-width: 768px) {
  .toast { max-width: calc(100vw - 32px); }
  .scroll-fab { width: 44px; height: 44px; bottom: 8px; right: 12px; }
}
</style>
</head>
<body>

<!-- Sidebar overlay for mobile -->
<div class="sidebar-overlay" id="sidebarOverlay" onclick="toggleSidebar()"></div>

<!-- Toast container -->
<div class="toast-container" id="toastContainer"></div>

<!-- Sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-header">
    <button onclick="createConversation()">+ New Chat</button>
    <button onclick="document.getElementById('charImportInput').click()" title="Import character card" style="flex:0 0 auto;padding:10px 12px">&#128101;</button>
    <input type="file" id="charImportInput" accept=".png,.json" style="display:none" onchange="importCharacterCard(event)">
  </div>
  <div class="sidebar-search">
    <input type="text" id="sidebarSearch" placeholder="Search conversations..." oninput="filterConversations()">
  </div>
  <div class="conv-list" id="convList"></div>
</div>

<!-- Main Area -->
<div class="main">
  <!-- Toolbar -->
  <div class="toolbar">
    <div class="toolbar-left">
      <button class="toolbar-toggle" onclick="toggleSidebar()" title="Toggle sidebar">&#9776;</button>
      <span class="toolbar-title">AI Assistant</span>
    </div>
    <div class="toolbar-right">
      <div class="toolbar-more">
        <button class="toolbar-btn" onclick="toggleToolbarMenu(event)" title="More actions">&#8943;</button>
        <div class="toolbar-menu" id="toolbarMenu">
          <button onclick="exportConversation();closeToolbarMenu()">&#8615; Export chat (JSON)</button>
          <button onclick="exportMarkdown();closeToolbarMenu()">&#128221; Export as Markdown</button>
          <button onclick="exportAllConversations();closeToolbarMenu()">&#8659; Export all chats</button>
          <button onclick="document.getElementById('importInput').click();closeToolbarMenu()">&#8613; Import chat</button>
          <button onclick="clearChat();closeToolbarMenu()">&#128465; Clear chat</button>
        </div>
      </div>
      <input type="file" id="importInput" accept=".json" style="display:none" onchange="importConversation(event)">
      <button class="toolbar-btn" id="charInfoBtn" onclick="showCharacterInfo()" title="Character info" style="display:none">&#8505;</button>
      <button class="toolbar-btn" onclick="openSettings()" title="Settings">&#9881;</button>
      <button class="toolbar-btn" id="themeToggle" onclick="toggleTheme()" title="Theme: dark">&#9790;</button>
    </div>
  </div>

  <!-- Chat search bar -->
  <div class="chat-search-bar" id="chatSearchBar">
    <input type="text" id="chatSearchInput" placeholder="Search in chat..." oninput="debouncedChatSearch()">
    <span class="search-count" id="chatSearchCount"></span>
    <button onclick="navigateChatSearch(-1)" title="Previous">&#9650;</button>
    <button onclick="navigateChatSearch(1)" title="Next">&#9660;</button>
    <button onclick="closeChatSearch()" title="Close">&times;</button>
  </div>

  <!-- Messages -->
  <div class="messages-area" id="messagesArea">
    <div class="chat-placeholder">Start a conversation...</div>
  </div>
  <button class="scroll-fab" id="scrollFab" onclick="document.getElementById('messagesArea').scrollTo({top:document.getElementById('messagesArea').scrollHeight,behavior:'smooth'})" title="Scroll to bottom">&#8595;</button>

  <!-- Input -->
  <div class="input-area">
    <div class="image-preview" id="imagePreview"></div>
    <div class="model-override-badge" id="modelOverrideBadge">
      <span id="modelOverrideText"></span>
      <button onclick="clearModelOverride()" title="Clear override">&times;</button>
    </div>
    <div class="input-row" style="position:relative">
      <div class="mention-dropdown" id="mentionDropdown"></div>
      <button class="input-btn" onclick="document.getElementById('fileInput').click()" title="Attach image">&#128206;</button>
      <input type="file" id="fileInput" accept="image/*" multiple style="display:none" onchange="handleFileSelect(event)">
      <textarea id="chatInput" placeholder="Type a message..." rows="1"></textarea>
      <button class="input-btn" id="voiceBtn" onclick="toggleVoice()" title="Voice input">&#127908;</button>
      <button class="send-btn" id="sendBtn" onclick="sendMessage()">Send</button>
    </div>
    <div class="token-info" id="tokenInfo"></div>
  </div>
</div>

<!-- Setup Modal -->
<div class="modal-overlay" id="setupModal">
  <div class="modal">
    <h2>Welcome to AI Assistant</h2>
    <p style="color:var(--text-secondary);font-size:0.9em;margin-bottom:20px">Enter your API settings to get started. Your keys are stored locally and never sent to any server except your configured proxy.</p>
    <label>Base URL</label>
    <input type="text" id="setupProxy" placeholder="https://api.openai.com/v1">
    <label>API Key</label>
    <input type="password" id="setupKey" placeholder="sk-...">
    <label>Model</label>
    <div class="model-selector-row">
      <select id="setupModelSelect" onchange="document.getElementById('setupModelManual').value=''"><option value="">-- Fetch models first --</option></select>
      <button class="model-refresh-btn" onclick="refreshModels('setup')" title="Refresh model list">&#x1F504;</button>
    </div>
    <input type="text" id="setupModelManual" placeholder="Or type model name manually" value="gpt-4o" oninput="document.getElementById('setupModelSelect').value=''">
    <div class="modal-actions">
      <button class="btn btn-primary" onclick="saveSetup()">Get Started</button>
    </div>
  </div>
</div>

<!-- Settings Modal -->
<div class="modal-overlay" id="settingsModal">
  <div class="modal">
    <h2>Settings</h2>

    <div class="modal-section">API Configuration</div>
    <label>Base URL</label>
    <input type="text" id="setProxy" placeholder="https://api.openai.com/v1">
    <label>API Key</label>
    <input type="password" id="setKey">
    <label>Model</label>
    <div class="model-selector-row">
      <select id="setModelSelect" onchange="document.getElementById('setModelManual').value=''"><option value="">-- Fetch models first --</option></select>
      <button class="model-refresh-btn" onclick="refreshModels('settings')" title="Refresh model list">&#x1F504;</button>
    </div>
    <input type="text" id="setModelManual" placeholder="Or type model name manually" oninput="document.getElementById('setModelSelect').value=''">
    <label>API Format</label>
    <select id="setApiFormat">
      <option value="auto">Auto-detect</option>
      <option value="openai">OpenAI</option>
      <option value="anthropic">Anthropic</option>
    </select>

    <div class="modal-section">Prompts</div>
    <label>Preset</label>
    <div class="model-selector-row">
      <select id="setPresetSelect" onchange="applyPreset(this.value)">
        <option value="">-- Custom --</option>
      </select>
      <button class="model-refresh-btn" onclick="saveCurrentAsPreset()" title="Save as preset">&#128190;</button>
      <button class="model-refresh-btn" onclick="deleteSelectedPreset()" title="Delete preset">&#128465;</button>
    </div>
    <label>System Prompt</label>
    <textarea id="setSystemPrompt" placeholder="You are a helpful assistant." rows="3"></textarea>
    <label>Persona (optional)</label>
    <textarea id="setPersona" placeholder="Describe yourself so the AI can personalize responses..."></textarea>

    <div class="modal-section">Request Parameters</div>
    <label class="toggle-row">
      <input type="checkbox" id="setStreaming" checked> Streaming
    </label>
    <label class="toggle-row">
      <input type="checkbox" id="setEnterSend" checked> Enter sends message
      <span class="toggle-hint">Ctrl+Enter if off</span>
    </label>
    <label>Temperature</label>
    <input type="number" id="setTemperature" step="0.1" min="0" max="2" placeholder="e.g. 0.7 (leave empty for default)">
    <label>Extra Parameters (JSON)</label>
    <textarea id="setExtraParams" placeholder='{"temperature": 0.7, "max_tokens": 4096}'></textarea>
    <label>Exclude Parameters (comma-separated)</label>
    <input type="text" id="setExcludeParams" placeholder="e.g. stream,model">

    <div class="modal-section">Appearance</div>
    <label>Theme</label>
    <select id="setTheme" onchange="onThemeSelectChange()">
      <option value="dark">Dark</option>
      <option value="light">Light</option>
      <option value="nord">Nord</option>
      <option value="catppuccin">Catppuccin</option>
      <option value="dracula">Dracula</option>
      <option value="gruvbox">Gruvbox</option>
      <option value="tokyonight">Tokyo Night</option>
      <option value="solarized">Solarized</option>
      <option value="onedark">One Dark</option>
      <option value="rosepine">Rose Pine</option>
      <option value="custom">Custom</option>
    </select>
    <div class="theme-colors" id="customThemeColors" style="display:none">
      <div class="theme-color-item"><input type="color" id="cBg" oninput="liveCustomTheme()"><span>Background</span></div>
      <div class="theme-color-item"><input type="color" id="cSidebar" oninput="liveCustomTheme()"><span>Sidebar</span></div>
      <div class="theme-color-item"><input type="color" id="cBorder" oninput="liveCustomTheme()"><span>Border</span></div>
      <div class="theme-color-item"><input type="color" id="cText" oninput="liveCustomTheme()"><span>Text</span></div>
      <div class="theme-color-item"><input type="color" id="cTextSec" oninput="liveCustomTheme()"><span>Text Secondary</span></div>
      <div class="theme-color-item"><input type="color" id="cAccent" oninput="liveCustomTheme()"><span>Accent</span></div>
      <div class="theme-color-item"><input type="color" id="cAccentHover" oninput="liveCustomTheme()"><span>Accent Hover</span></div>
      <div class="theme-color-item"><input type="color" id="cMsgUser" oninput="liveCustomTheme()"><span>User Bubble</span></div>
      <div class="theme-color-item"><input type="color" id="cMsgAssistant" oninput="liveCustomTheme()"><span>Assistant Bubble</span></div>
    </div>
    <label>Font</label>
    <input type="text" id="setFont" placeholder="e.g. Inter, Poppins, JetBrains Mono">

    <div class="modal-section">Tools</div>
    <label class="toggle-row">
      <input type="checkbox" id="setWebSearch"> Web Search
      <span class="toggle-hint">Anthropic only</span>
    </label>

    <div class="modal-section">Cost Tracking</div>
    <label>Input Cost per 1M tokens</label>
    <input type="number" id="setInputCost" step="0.01" placeholder="e.g. 2.50">
    <label>Output Cost per 1M tokens</label>
    <input type="number" id="setOutputCost" step="0.01" placeholder="e.g. 10.00">

    <div class="modal-actions">
      <button class="btn btn-secondary" onclick="closeSettings()">Cancel</button>
      <button class="btn btn-primary" onclick="saveSettings()">Save</button>
    </div>
  </div>
</div>

<!-- Keyboard Shortcuts Modal -->
<div class="modal-overlay" id="shortcutsModal">
  <div class="modal" style="max-width:480px">
    <h2>Keyboard Shortcuts</h2>
    <div style="display:grid;grid-template-columns:auto 1fr;gap:8px 16px;font-size:0.85em">
      <kbd style="background:var(--hover);padding:2px 8px;border-radius:4px;font-family:inherit;white-space:nowrap">Enter</kbd><span>Send message (configurable)</span>
      <kbd style="background:var(--hover);padding:2px 8px;border-radius:4px;font-family:inherit;white-space:nowrap">Shift+Enter</kbd><span>New line in input</span>
      <kbd style="background:var(--hover);padding:2px 8px;border-radius:4px;font-family:inherit;white-space:nowrap">Ctrl+Enter</kbd><span>Always sends message</span>
      <kbd style="background:var(--hover);padding:2px 8px;border-radius:4px;font-family:inherit;white-space:nowrap">Ctrl+N</kbd><span>New conversation</span>
      <kbd style="background:var(--hover);padding:2px 8px;border-radius:4px;font-family:inherit;white-space:nowrap">Ctrl+/</kbd><span>Focus input</span>
      <kbd style="background:var(--hover);padding:2px 8px;border-radius:4px;font-family:inherit;white-space:nowrap">Ctrl+K</kbd><span>Search conversations</span>
      <kbd style="background:var(--hover);padding:2px 8px;border-radius:4px;font-family:inherit;white-space:nowrap">Ctrl+F</kbd><span>Search in current chat</span>
      <kbd style="background:var(--hover);padding:2px 8px;border-radius:4px;font-family:inherit;white-space:nowrap">Ctrl+Shift+E</kbd><span>Export all conversations</span>
      <kbd style="background:var(--hover);padding:2px 8px;border-radius:4px;font-family:inherit;white-space:nowrap">Escape</kbd><span>Close modal / Stop streaming</span>
      <kbd style="background:var(--hover);padding:2px 8px;border-radius:4px;font-family:inherit;white-space:nowrap">Ctrl+Shift+?</kbd><span>Show this help</span>
      <kbd style="background:var(--hover);padding:2px 8px;border-radius:4px;font-family:inherit;white-space:nowrap">@model</kbd><span>Override model for one message</span>
    </div>
    <div class="modal-actions" style="margin-top:16px">
      <button class="btn btn-primary" onclick="document.getElementById('shortcutsModal').classList.remove('open')">Close</button>
    </div>
  </div>
</div>

<script>
// ============================================
// State
// ============================================
let conversations = [];
let activeConvId = null;
let messages = [];
let abortController = null;
let streaming = false;
let pendingImages = [];
let voiceRec = null;
let modelOverride = null;
let mentionActive = false;
let mentionIdx = 0;

// ============================================
// Toast Notifications
// ============================================
function showToast(message, type = 'info', duration = 3000) {
  const container = document.getElementById('toastContainer');
  const toast = document.createElement('div');
  toast.className = 'toast ' + type;
  toast.textContent = message;
  container.appendChild(toast);
  setTimeout(() => {
    toast.classList.add('removing');
    setTimeout(() => toast.remove(), 300);
  }, duration);
}

// ============================================
// Theme Presets
// ============================================
const themePresets = {
  dark:       { bg:'#0a0a0f', sidebar:'#14141a', cardBorder:'rgba(255,255,255,0.08)', textPrimary:'rgba(255,255,255,0.95)', textSecondary:'rgba(255,255,255,0.6)', accent:'#6366f1', accentHover:'#818cf8', msgUser:'#6366f1', msgAssistant:'rgba(255,255,255,0.08)' },
  light:      { bg:'#f5f5f7', sidebar:'#eeeef2', cardBorder:'rgba(0,0,0,0.1)', textPrimary:'rgba(0,0,0,0.9)', textSecondary:'rgba(0,0,0,0.5)', accent:'#6366f1', accentHover:'#818cf8', msgUser:'#6366f1', msgAssistant:'rgba(0,0,0,0.05)' },
  nord:       { bg:'#2e3440', sidebar:'#3b4252', cardBorder:'#434c5e', textPrimary:'#eceff4', textSecondary:'#d8dee9', accent:'#88c0d0', accentHover:'#8fbcbb', msgUser:'#5e81ac', msgAssistant:'#3b4252' },
  catppuccin: { bg:'#1e1e2e', sidebar:'#313244', cardBorder:'#45475a', textPrimary:'#cdd6f4', textSecondary:'#a6adc8', accent:'#cba6f7', accentHover:'#b4befe', msgUser:'#cba6f7', msgAssistant:'#313244' },
  dracula:    { bg:'#282a36', sidebar:'#44475a', cardBorder:'#6272a4', textPrimary:'#f8f8f2', textSecondary:'#bd93f9', accent:'#bd93f9', accentHover:'#ff79c6', msgUser:'#bd93f9', msgAssistant:'#44475a' },
  gruvbox:    { bg:'#282828', sidebar:'#3c3836', cardBorder:'#504945', textPrimary:'#ebdbb2', textSecondary:'#a89984', accent:'#fabd2f', accentHover:'#fe8019', msgUser:'#fabd2f', msgAssistant:'#3c3836' },
  tokyonight: { bg:'#1a1b26', sidebar:'#24283b', cardBorder:'#414868', textPrimary:'#c0caf5', textSecondary:'#565f89', accent:'#7aa2f7', accentHover:'#bb9af7', msgUser:'#7aa2f7', msgAssistant:'#24283b' },
  solarized:  { bg:'#002b36', sidebar:'#073642', cardBorder:'#586e75', textPrimary:'#fdf6e3', textSecondary:'#93a1a1', accent:'#268bd2', accentHover:'#2aa198', msgUser:'#268bd2', msgAssistant:'#073642' },
  onedark:    { bg:'#282c34', sidebar:'#21252b', cardBorder:'#3e4451', textPrimary:'#abb2bf', textSecondary:'#5c6370', accent:'#61afef', accentHover:'#c678dd', msgUser:'#61afef', msgAssistant:'#2c313c' },
  rosepine:   { bg:'#191724', sidebar:'#1f1d2e', cardBorder:'#26233a', textPrimary:'#e0def4', textSecondary:'#908caa', accent:'#c4a7e7', accentHover:'#ebbcba', msgUser:'#c4a7e7', msgAssistant:'#1f1d2e' }
};

const themeOrder = ['dark','light','nord','catppuccin','dracula','gruvbox','tokyonight','solarized','onedark','rosepine'];

// ============================================
// Utility
// ============================================
function isLightColor(color) {
  let hex = color;
  if (hex.startsWith('rgba') || hex.startsWith('rgb')) {
    const m = hex.match(/[\d.]+/g);
    if (m) return (parseFloat(m[0]) * 299 + parseFloat(m[1]) * 587 + parseFloat(m[2]) * 114) / 1000 > 128;
    return false;
  }
  if (hex.startsWith('#')) {
    hex = hex.slice(1);
    if (hex.length === 3) hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
    const r = parseInt(hex.slice(0,2), 16), g = parseInt(hex.slice(2,4), 16), b = parseInt(hex.slice(4,6), 16);
    return (r * 299 + g * 587 + b * 114) / 1000 > 128;
  }
  return false;
}

// ============================================
// Theme System
// ============================================
function applyTheme(name) {
  let t;
  if (name === 'custom') {
    try { t = JSON.parse(localStorage.getItem('assistantCustomTheme') || 'null'); } catch(e) {}
    if (!t) t = themePresets.dark;
  } else {
    t = themePresets[name] || themePresets.dark;
  }
  const s = document.documentElement.style;
  s.setProperty('--bg', t.bg);
  s.setProperty('--sidebar-bg', t.sidebar);
  s.setProperty('--card-border', t.cardBorder);
  s.setProperty('--text-primary', t.textPrimary);
  s.setProperty('--text-secondary', t.textSecondary);
  s.setProperty('--accent', t.accent);
  s.setProperty('--accent-hover', t.accentHover);
  s.setProperty('--msg-user', t.msgUser);
  s.setProperty('--msg-assistant', t.msgAssistant);
  s.setProperty('--hover', isLightColor(t.bg) ? 'rgba(0,0,0,0.05)' : 'rgba(255,255,255,0.05)');
  localStorage.setItem('assistantTheme', name);

  const btn = document.getElementById('themeToggle');
  if (btn) {
    btn.innerHTML = isLightColor(t.bg) ? '&#9728;' : '&#9790;';
    btn.title = 'Theme: ' + name;
  }
}

function toggleTheme() {
  const current = localStorage.getItem('assistantTheme') || 'dark';
  let order = [...themeOrder];
  const hasCustom = localStorage.getItem('assistantCustomTheme');
  if (hasCustom) order.push('custom');
  let idx = order.indexOf(current);
  const next = order[(idx + 1) % order.length];
  applyTheme(next);

  // Flash theme name
  const btn = document.getElementById('themeToggle');
  const old = btn.querySelector('.theme-flash');
  if (old) old.remove();
  const flash = document.createElement('span');
  flash.className = 'theme-flash';
  flash.textContent = next;
  btn.appendChild(flash);
  setTimeout(() => flash.remove(), 1600);
}

function loadTheme() {
  const name = localStorage.getItem('assistantTheme') || 'dark';
  applyTheme(name);
}

// ============================================
// Custom Theme Helpers
// ============================================
function onThemeSelectChange() {
  const val = document.getElementById('setTheme').value;
  document.getElementById('customThemeColors').style.display = val === 'custom' ? 'grid' : 'none';
  if (val === 'custom') {
    loadCustomColorPickers();
  }
  applyTheme(val);
}

function loadCustomColorPickers() {
  let t;
  try { t = JSON.parse(localStorage.getItem('assistantCustomTheme') || 'null'); } catch(e) {}
  if (!t) t = themePresets.dark;
  const toHex = (c) => {
    if (c.startsWith('#') && c.length >= 7) return c.slice(0, 7);
    if (c.startsWith('#') && c.length === 4) return '#' + c[1]+c[1]+c[2]+c[2]+c[3]+c[3];
    if (c.startsWith('rgba') || c.startsWith('rgb')) {
      const m = c.match(/[\d.]+/g);
      if (m) return '#' + [m[0],m[1],m[2]].map(v => Math.round(parseFloat(v)).toString(16).padStart(2,'0')).join('');
    }
    return '#000000';
  };
  document.getElementById('cBg').value = toHex(t.bg);
  document.getElementById('cSidebar').value = toHex(t.sidebar);
  document.getElementById('cBorder').value = toHex(t.cardBorder);
  document.getElementById('cText').value = toHex(t.textPrimary);
  document.getElementById('cTextSec').value = toHex(t.textSecondary);
  document.getElementById('cAccent').value = toHex(t.accent);
  document.getElementById('cAccentHover').value = toHex(t.accentHover);
  document.getElementById('cMsgUser').value = toHex(t.msgUser);
  document.getElementById('cMsgAssistant').value = toHex(t.msgAssistant);
}

function getCustomThemeFromPickers() {
  return {
    bg: document.getElementById('cBg').value,
    sidebar: document.getElementById('cSidebar').value,
    cardBorder: document.getElementById('cBorder').value,
    textPrimary: document.getElementById('cText').value,
    textSecondary: document.getElementById('cTextSec').value,
    accent: document.getElementById('cAccent').value,
    accentHover: document.getElementById('cAccentHover').value,
    msgUser: document.getElementById('cMsgUser').value,
    msgAssistant: document.getElementById('cMsgAssistant').value
  };
}

function liveCustomTheme() {
  const t = getCustomThemeFromPickers();
  localStorage.setItem('assistantCustomTheme', JSON.stringify(t));
  applyTheme('custom');
}

// ============================================
// Custom Google Fonts
// ============================================
function loadCustomFont(fontName) {
  const old = document.getElementById('customFontLink');
  if (old) old.remove();
  if (!fontName) {
    document.body.style.fontFamily = "'Figtree', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif";
    return;
  }
  const link = document.createElement('link');
  link.id = 'customFontLink';
  link.rel = 'stylesheet';
  link.href = 'https://fonts.googleapis.com/css2?family=' + fontName.replace(/ /g, '+') + ':wght@400;500;600;700&display=swap';
  document.head.appendChild(link);
  document.body.style.fontFamily = "'" + fontName + "', 'Figtree', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif";
}

// ============================================
// Model Fetching
// ============================================
async function fetchAvailableModels(baseUrl, apiKey) {
  const url = baseUrl.replace(/\/+$/, '') + '/models';
  const resp = await fetch(url, {
    headers: { 'Authorization': 'Bearer ' + apiKey }
  });
  if (!resp.ok) throw new Error('HTTP ' + resp.status);
  const data = await resp.json();
  return data.data?.map(m => m.id) || [];
}

function populateModelSelect(target, models) {
  const select = document.getElementById(target === 'setup' ? 'setupModelSelect' : 'setModelSelect');
  const currentModel = localStorage.getItem('llmModel') || '';
  select.innerHTML = '<option value="">-- Select a model --</option>';
  models.sort().forEach(m => {
    const opt = document.createElement('option');
    opt.value = m;
    opt.textContent = m;
    if (m === currentModel) opt.selected = true;
    select.appendChild(opt);
  });
}

async function refreshModels(target) {
  const proxyInput = document.getElementById(target === 'setup' ? 'setupProxy' : 'setProxy');
  const keyInput = document.getElementById(target === 'setup' ? 'setupKey' : 'setKey');
  let baseUrl = proxyInput.value.trim().replace(/\/(chat\/completions|messages)\/?$/, '');
  const apiKey = keyInput.value.trim();
  if (!baseUrl || !apiKey) { showToast('Enter Base URL and API Key first.', 'error'); return; }
  const btn = event.target;
  btn.textContent = '...';
  btn.disabled = true;
  try {
    const models = await fetchAvailableModels(baseUrl, apiKey);
    localStorage.setItem('llmModelList', JSON.stringify(models));
    populateModelSelect(target, models);
  } catch (e) {
    showToast('Failed to fetch models: ' + e.message, 'error');
  } finally {
    btn.textContent = '\u{1F504}';
    btn.disabled = false;
  }
}

function loadCachedModels(target) {
  try {
    const cached = JSON.parse(localStorage.getItem('llmModelList') || '[]');
    if (cached.length > 0) populateModelSelect(target, cached);
  } catch(e) {}
}

// ============================================
// API Format Detection
// ============================================
function detectApiFormat(model) {
  const fmt = localStorage.getItem('llmApiFormat') || 'auto';
  if (fmt !== 'auto') return fmt;
  if (/^claude/i.test(model)) return 'anthropic';
  return 'openai';
}

// ============================================
// Anthropic Message Conversion
// ============================================
function prepareAnthropicMessages(apiMessages) {
  let systemText = '';
  const msgs = [];
  for (const m of apiMessages) {
    if (m.role === 'system') {
      const txt = typeof m.content === 'string' ? m.content : '';
      systemText += (systemText ? '\n\n' : '') + txt;
    } else {
      msgs.push({ role: m.role, content: m.content });
    }
  }
  // Merge consecutive same-role messages
  const merged = [];
  for (const m of msgs) {
    if (merged.length > 0 && merged[merged.length - 1].role === m.role) {
      const prev = merged[merged.length - 1];
      const prevText = typeof prev.content === 'string' ? prev.content : JSON.stringify(prev.content);
      const curText = typeof m.content === 'string' ? m.content : JSON.stringify(m.content);
      prev.content = prevText + '\n\n' + curText;
    } else {
      merged.push({ role: m.role, content: m.content });
    }
  }
  // Convert image content for Anthropic format
  const converted = merged.map(m => {
    if (Array.isArray(m.content)) {
      const parts = m.content.map(part => {
        if (part.type === 'text') return { type: 'text', text: part.text };
        if (part.type === 'image_url') {
          const url = part.image_url.url;
          if (url.startsWith('data:')) {
            const match = url.match(/^data:(image\/[^;]+);base64,(.+)$/);
            if (match) return { type: 'image', source: { type: 'base64', media_type: match[1], data: match[2] } };
          }
          return { type: 'image', source: { type: 'url', url: url } };
        }
        return part;
      });
      return { role: m.role, content: parts };
    }
    return m;
  });
  return { system: systemText, messages: converted };
}

// ============================================
// Initialization
// ============================================
document.addEventListener('DOMContentLoaded', () => {
  // Migration: strip endpoint suffix from proxy URL
  const storedUrl = localStorage.getItem('llmProxyUrl');
  if (storedUrl) {
    const cleaned = storedUrl.replace(/\/(chat\/completions|messages)\/?$/, '');
    if (cleaned !== storedUrl) localStorage.setItem('llmProxyUrl', cleaned);
  }

  loadConversations();
  loadTheme();
  loadCustomFont(localStorage.getItem('assistantFont') || '');
  loadCachedModels('setup');
  loadCachedModels('settings');

  // Show setup modal if no API key
  if (!localStorage.getItem('llmProxyUrl') || !localStorage.getItem('llmApiKey')) {
    document.getElementById('setupModal').classList.add('open');
  }

  // Hide voice button if unsupported
  if (!(window.SpeechRecognition || window.webkitSpeechRecognition)) {
    document.getElementById('voiceBtn').style.display = 'none';
  }

  // Auto-resize textarea + character count + @model mentions
  const ta = document.getElementById('chatInput');
  ta.addEventListener('input', () => {
    ta.style.height = 'auto';
    ta.style.height = Math.min(ta.scrollHeight, 150) + 'px';
    updateTokenInfo();
    handleMentionInput(ta);
  });

  // Send on Enter (with mention dropdown handling)
  ta.addEventListener('keydown', (e) => {
    if (mentionActive) {
      handleMentionKeydown(e, ta);
      if (e.defaultPrevented) return;
    }
    if (e.key === 'Enter' && !e.shiftKey) {
      const enterSends = localStorage.getItem('llmEnterSend') !== 'false';
      if (enterSends) {
        e.preventDefault();
        sendMessage();
      }
    }
    if (e.key === 'Enter' && e.ctrlKey) {
      e.preventDefault();
      sendMessage();
    }
  });

  // Global keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    // Escape - close modals / stop streaming
    if (e.key === 'Escape') {
      if (document.getElementById('chatSearchBar').classList.contains('open')) {
        closeChatSearch();
        return;
      }
      if (streaming && abortController) abortController.abort();
      document.getElementById('settingsModal').classList.remove('open');
      document.getElementById('setupModal').classList.remove('open');
      document.getElementById('shortcutsModal').classList.remove('open');
    }
    // Ctrl+N - new conversation
    if (e.ctrlKey && e.key === 'n') {
      e.preventDefault();
      createConversation();
    }
    // Ctrl+/ - focus input
    if (e.ctrlKey && e.key === '/') {
      e.preventDefault();
      document.getElementById('chatInput').focus();
    }
    // Ctrl+K - focus sidebar search
    if (e.ctrlKey && e.key === 'k') {
      e.preventDefault();
      const sb = document.getElementById('sidebar');
      if (sb.classList.contains('collapsed')) toggleSidebar();
      document.getElementById('sidebarSearch').focus();
    }
    // Ctrl+Shift+E - export all
    if (e.ctrlKey && e.shiftKey && e.key === 'E') {
      e.preventDefault();
      exportAllConversations();
    }
    // Ctrl+F - chat search
    if (e.ctrlKey && e.key === 'f') {
      e.preventDefault();
      openChatSearch();
    }
    // Ctrl+Shift+? - shortcut help
    if (e.ctrlKey && e.shiftKey && e.key === '?') {
      e.preventDefault();
      document.getElementById('shortcutsModal').classList.add('open');
    }
  });

  // Drag & drop images
  const main = document.querySelector('.main');
  main.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
  main.addEventListener('drop', (e) => {
    e.preventDefault();
    Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/')).forEach(readImageFile);
  });

  // Paste images
  ta.addEventListener('paste', (e) => {
    Array.from(e.clipboardData?.items || []).forEach(item => {
      if (item.type.startsWith('image/')) {
        e.preventDefault();
        readImageFile(item.getAsFile());
      }
    });
  });

  // Mobile: collapse sidebar by default
  if (window.innerWidth <= 768) {
    document.getElementById('sidebar').classList.add('collapsed');
  }

  // Scroll-to-bottom FAB
  const msgsArea = document.getElementById('messagesArea');
  const scrollFab = document.getElementById('scrollFab');
  msgsArea.addEventListener('scroll', () => {
    const atBottom = msgsArea.scrollHeight - msgsArea.scrollTop - msgsArea.clientHeight < 100;
    scrollFab.classList.toggle('visible', !atBottom);
  });

  // Initialize mermaid
  if (typeof mermaid !== 'undefined') {
    mermaid.initialize({ startOnLoad: false, theme: 'dark' });
  }
});

// ============================================
// Markdown Renderer
// ============================================
function renderMarkdown(text) {
  if (!text) return '';

  // Extract KaTeX math before HTML escaping
  const mathPlaceholders = [];
  let s = text;
  // Block math $$...$$
  s = s.replace(/\$\$([\s\S]+?)\$\$/g, (_, math) => {
    const idx = mathPlaceholders.length;
    mathPlaceholders.push({ math, display: true });
    return '\x00MATH' + idx + '\x00';
  });
  // Inline math $...$
  s = s.replace(/\$([^\$\n]+?)\$/g, (_, math) => {
    const idx = mathPlaceholders.length;
    mathPlaceholders.push({ math, display: false });
    return '\x00MATH' + idx + '\x00';
  });

  // Decode HTML entities that models sometimes output before escaping
  s = s.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#39;/g, "'");
  s = s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  // Spoiler tags >!hidden text!<
  s = s.replace(/&gt;!([\s\S]*?)!&lt;/g, '<span class="spoiler" onclick="this.classList.toggle(\'revealed\')">$1</span>');
  // Mermaid code blocks
  s = s.replace(/```mermaid\n([\s\S]*?)```/g, (_, code) =>
    '<div class="mermaid-container"><pre class="mermaid">' + code.trimEnd() + '</pre></div>');
  s = s.replace(/```(\w*)\n([\s\S]*?)```/g, (_, lang, code) =>
    '<pre><code' + (lang ? ' class="language-' + lang + '"' : '') + '>' + code.trimEnd() + '</code></pre>');
  s = s.replace(/`([^`\n]+)`/g, '<code>$1</code>');
  s = s.replace(/^#### (.+)$/gm, '<h4>$1</h4>');
  s = s.replace(/^### (.+)$/gm, '<h3>$1</h3>');
  s = s.replace(/^## (.+)$/gm, '<h2>$1</h2>');
  s = s.replace(/^# (.+)$/gm, '<h1>$1</h1>');
  s = s.replace(/\*\*\*(.+?)\*\*\*/g, '<strong><em>$1</em></strong>');
  s = s.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  s = s.replace(/(?<!\*)\*([^*\n]+)\*(?!\*)/g, '<em>$1</em>');
  s = s.replace(/^&gt; (.+)$/gm, '<blockquote>$1</blockquote>');
  s = s.replace(/^[\-\*] (.+)$/gm, '<li>$1</li>');
  s = s.replace(/((?:<li>.*<\/li>\n?)+)/g, '<ul>$1</ul>');
  s = s.replace(/^\d+\. (.+)$/gm, '<li>$1</li>');
  s = s.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');
  s = s.replace(/^---$/gm, '<hr>');
  const parts = s.split(/(<pre>[\s\S]*?<\/pre>|<div class="mermaid-container">[\s\S]*?<\/div>)/g);
  s = parts.map(part => (part.startsWith('<pre>') || part.startsWith('<div class="mermaid')) ? part : part.replace(/\n/g, '<br>')).join('');

  // Restore KaTeX math placeholders
  s = s.replace(/\x00MATH(\d+)\x00/g, (_, idx) => {
    const ph = mathPlaceholders[parseInt(idx)];
    if (typeof katex !== 'undefined') {
      try { return katex.renderToString(ph.math, { displayMode: ph.display, throwOnError: false }); } catch(e) {}
    }
    return (ph.display ? '$$' : '$') + ph.math.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') + (ph.display ? '$$' : '$');
  });

  return s;
}

// ============================================
// Code Copy Buttons
// ============================================
function addCodeCopyButtons(container) {
  const langExtMap = { javascript: 'js', js: 'js', typescript: 'ts', ts: 'ts', python: 'py', py: 'py', java: 'java', c: 'c', cpp: 'cpp', csharp: 'cs', cs: 'cs', go: 'go', rust: 'rs', ruby: 'rb', php: 'php', html: 'html', css: 'css', json: 'json', xml: 'xml', yaml: 'yaml', yml: 'yml', sql: 'sql', bash: 'sh', sh: 'sh', shell: 'sh', markdown: 'md', md: 'md', swift: 'swift', kotlin: 'kt', lua: 'lua', r: 'r', perl: 'pl', scala: 'scala', dart: 'dart', zig: 'zig', nim: 'nim', elixir: 'ex', clojure: 'clj', haskell: 'hs', ocaml: 'ml', toml: 'toml', ini: 'ini', dockerfile: 'dockerfile', makefile: 'makefile' };
  container.querySelectorAll('pre').forEach(pre => {
    if (pre.parentElement.classList.contains('code-block-wrapper')) return;
    if (pre.classList.contains('mermaid')) return;
    const wrapper = document.createElement('div');
    wrapper.className = 'code-block-wrapper';
    pre.parentNode.insertBefore(wrapper, pre);
    wrapper.appendChild(pre);
    const btn = document.createElement('button');
    btn.className = 'code-copy-btn';
    btn.textContent = 'Copy';
    btn.onclick = (e) => {
      e.stopPropagation();
      const code = pre.querySelector('code');
      navigator.clipboard.writeText(code ? code.textContent : pre.textContent);
      btn.textContent = 'Copied!';
      setTimeout(() => btn.textContent = 'Copy', 2000);
    };
    wrapper.appendChild(btn);
    // Download button
    const code = pre.querySelector('code');
    if (code) {
      const cls = Array.from(code.classList).find(c => c.startsWith('language-'));
      const lang = cls ? cls.replace('language-', '') : '';
      const ext = langExtMap[lang] || lang || 'txt';
      const dlBtn = document.createElement('button');
      dlBtn.className = 'code-download-btn';
      dlBtn.textContent = '\u2913';
      dlBtn.title = 'Download as .' + ext;
      dlBtn.onclick = (e) => {
        e.stopPropagation();
        const blob = new Blob([code.textContent], { type: 'text/plain' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'code.' + ext;
        a.click();
        URL.revokeObjectURL(a.href);
      };
      wrapper.appendChild(dlBtn);
    }
  });
}

// ============================================
// Syntax Highlighting
// ============================================
function highlightCodeBlocks(container) {
  if (typeof hljs === 'undefined') return;
  container.querySelectorAll('pre code[class^="language-"]').forEach(el => {
    if (el.dataset.highlighted) return;
    hljs.highlightElement(el);
    el.dataset.highlighted = 'true';
  });
}

// ============================================
// Line Numbers
// ============================================
function addLineNumbers(container) {
  container.querySelectorAll('pre code').forEach(code => {
    if (code.parentElement.classList.contains('has-line-numbers')) return;
    if (code.parentElement.classList.contains('mermaid')) return;
    const lines = code.innerHTML.split('\n');
    if (lines.length < 3) return;
    // Remove trailing empty line if present
    if (lines[lines.length - 1].trim() === '') lines.pop();
    code.innerHTML = lines.map(l => '<span class="code-line">' + l + '</span>').join('\n');
    code.parentElement.classList.add('has-line-numbers');
  });
}

// ============================================
// Mermaid Rendering
// ============================================
let mermaidIdCounter = 0;
async function renderMermaidBlocks(container) {
  if (typeof mermaid === 'undefined') return;
  const pres = container.querySelectorAll('pre.mermaid');
  for (const pre of pres) {
    if (pre.dataset.rendered) continue;
    pre.dataset.rendered = 'true';
    try {
      const id = 'mermaid-' + (mermaidIdCounter++);
      const { svg } = await mermaid.render(id, pre.textContent);
      const div = document.createElement('div');
      div.innerHTML = svg;
      pre.replaceWith(div.firstElementChild);
    } catch (e) {
      pre.textContent = 'Mermaid error: ' + e.message;
    }
  }
}

// ============================================
// Post-Render Pipeline
// ============================================
function postRenderProcessing(bubble) {
  addCodeCopyButtons(bubble);
  highlightCodeBlocks(bubble);
  addLineNumbers(bubble);
  renderMermaidBlocks(bubble);
}

// ============================================
// Token Estimation
// ============================================
function estimateTokens(text) {
  if (!text) return 0;
  return Math.ceil(text.split(/[\s,.!?;:'"()\[\]{}]+/).filter(Boolean).length * 1.3);
}

function getMsgText(msg) {
  if (typeof msg.content === 'string') return msg.content;
  if (Array.isArray(msg.content)) return msg.content.filter(c => c.type === 'text').map(c => c.text).join(' ');
  return '';
}

function updateTokenInfo() {
  const el = document.getElementById('tokenInfo');
  const inputText = document.getElementById('chatInput').value;
  const inputChars = inputText.length;

  const parts = [];
  if (inputChars > 0) {
    const inputTokens = estimateTokens(inputText);
    parts.push(inputChars + ' chars');
    parts.push('~' + (inputTokens > 999 ? (inputTokens / 1000).toFixed(1) + 'k' : inputTokens) + ' tokens');
  }

  let total = 0;
  messages.forEach(m => { total += estimateTokens(getMsgText(m)); });
  if (total > 0 || messages.length > 0) {
    parts.push('Conv: ~' + (total > 999 ? (total / 1000).toFixed(1) + 'k' : total) + ' tokens');
  }

  const inputCost = parseFloat(localStorage.getItem('llmInputCost') || '0');
  const outputCost = parseFloat(localStorage.getItem('llmOutputCost') || '0');
  if ((inputCost > 0 || outputCost > 0) && total > 0) {
    let cost = 0;
    messages.forEach(m => {
      const t = estimateTokens(getMsgText(m));
      cost += t * ((m.role === 'assistant' ? outputCost : inputCost) / 1000000);
    });
    parts.push('~$' + cost.toFixed(4));
  }
  el.textContent = parts.join(' | ');
}

// ============================================
// Conversation Management
// ============================================
function genId() { return 'conv_' + Date.now() + '_' + Math.random().toString(36).slice(2, 6); }

function saveConversations() {
  localStorage.setItem('assistantConversations', JSON.stringify(conversations));
  localStorage.setItem('assistantActiveConvId', activeConvId || '');
}

function loadConversations() {
  const saved = localStorage.getItem('assistantConversations');
  if (saved) conversations = JSON.parse(saved);

  // Migrate legacy
  const legacy = localStorage.getItem('assistantChatHistory');
  if (legacy && conversations.length === 0) {
    conversations.push({ id: genId(), title: 'Chat', messages: JSON.parse(legacy), createdAt: Date.now(), updatedAt: Date.now() });
    localStorage.removeItem('assistantChatHistory');
  }

  if (conversations.length === 0) {
    conversations.push({ id: genId(), title: 'New Chat', messages: [], createdAt: Date.now(), updatedAt: Date.now() });
  }

  // Migrate swipes
  conversations.forEach(c => c.messages.forEach(m => {
    if (m.role === 'assistant' && !m.swipes) { m.swipes = [typeof m.content === 'string' ? m.content : '']; m.swipeIndex = 0; }
  }));

  const savedActive = localStorage.getItem('assistantActiveConvId');
  activeConvId = (savedActive && conversations.find(c => c.id === savedActive)) ? savedActive : conversations[0].id;
  messages = getActiveConv().messages;

  saveConversations();
  renderSidebar();
  renderMessages();
  updateTokenInfo();
  updateCharacterUI();
}

function getActiveConv() { return conversations.find(c => c.id === activeConvId); }

function createConversation() {
  const conv = { id: genId(), title: 'New Chat', messages: [], createdAt: Date.now(), updatedAt: Date.now() };
  conversations.unshift(conv);
  activeConvId = conv.id;
  messages = conv.messages;
  saveConversations();
  renderSidebar();
  renderMessages();
  updateTokenInfo();
  updateCharacterUI();
  if (window.innerWidth <= 768) toggleSidebar();
}

function switchConversation(id) {
  const conv = conversations.find(c => c.id === id);
  if (!conv) return;
  activeConvId = id;
  messages = conv.messages;
  saveConversations();
  renderSidebar();
  renderMessages();
  updateTokenInfo();
  updateCharacterUI();
  if (window.innerWidth <= 768) toggleSidebar();
}

function deleteConversation(id, e) {
  e.stopPropagation();
  conversations = conversations.filter(c => c.id !== id);
  if (conversations.length === 0) {
    createConversation();
    return;
  }
  if (activeConvId === id) switchConversation(conversations[0].id);
  saveConversations();
  renderSidebar();
}

function renderSidebar() {
  const list = document.getElementById('convList');
  list.innerHTML = '';

  // Sort: pinned first (by updatedAt desc), then unpinned by updatedAt desc
  // If any have sortOrder, use that instead
  const hasSortOrder = conversations.some(c => c.sortOrder != null);
  const sorted = [...conversations].sort((a, b) => {
    if (a.pinned && !b.pinned) return -1;
    if (!a.pinned && b.pinned) return 1;
    if (hasSortOrder && a.sortOrder != null && b.sortOrder != null) return a.sortOrder - b.sortOrder;
    return (b.updatedAt || 0) - (a.updatedAt || 0);
  });

  // Date grouping
  const now = new Date();
  const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
  const yesterdayStart = todayStart - 86400000;
  const weekStart = todayStart - 7 * 86400000;
  const monthStart = todayStart - 30 * 86400000;

  function getGroup(c) {
    if (c.pinned) return 'Pinned';
    const t = c.updatedAt || c.createdAt || 0;
    if (t >= todayStart) return 'Today';
    if (t >= yesterdayStart) return 'Yesterday';
    if (t >= weekStart) return 'Last 7 Days';
    if (t >= monthStart) return 'Last 30 Days';
    return 'Older';
  }

  let lastGroup = '';
  sorted.forEach((c, sortIdx) => {
    const group = getGroup(c);
    if (group !== lastGroup) {
      const header = document.createElement('div');
      header.className = 'conv-group-header';
      header.textContent = group;
      header.dataset.group = group;
      list.appendChild(header);
      lastGroup = group;
    }

    const div = document.createElement('div');
    div.className = 'conv-item' + (c.id === activeConvId ? ' active' : '');
    div.onclick = () => switchConversation(c.id);
    div.dataset.convId = c.id;

    // Drag-and-drop (desktop only)
    div.draggable = true;
    div.addEventListener('dragstart', (e) => {
      e.dataTransfer.setData('text/plain', c.id);
      div.classList.add('dragging');
    });
    div.addEventListener('dragend', () => div.classList.remove('dragging'));
    div.addEventListener('dragover', (e) => { e.preventDefault(); div.classList.add('drag-over'); });
    div.addEventListener('dragleave', () => div.classList.remove('drag-over'));
    div.addEventListener('drop', (e) => {
      e.preventDefault();
      div.classList.remove('drag-over');
      const draggedId = e.dataTransfer.getData('text/plain');
      if (draggedId === c.id) return;
      const fromIdx = conversations.findIndex(x => x.id === draggedId);
      const toIdx = conversations.findIndex(x => x.id === c.id);
      if (fromIdx === -1 || toIdx === -1) return;
      const [moved] = conversations.splice(fromIdx, 1);
      conversations.splice(toIdx, 0, moved);
      conversations.forEach((x, i) => x.sortOrder = i);
      saveConversations();
      renderSidebar();
    });

    const pinBtn = document.createElement('button');
    pinBtn.className = 'conv-pin' + (c.pinned ? ' pinned' : '');
    pinBtn.innerHTML = '&#128204;';
    pinBtn.title = c.pinned ? 'Unpin' : 'Pin';
    pinBtn.onclick = (e) => {
      e.stopPropagation();
      c.pinned = !c.pinned;
      saveConversations();
      renderSidebar();
    };

    const title = document.createElement('span');
    title.className = 'conv-title';
    title.textContent = c.title;

    const del = document.createElement('button');
    del.className = 'conv-delete';
    del.innerHTML = '&times;';
    del.onclick = (e) => deleteConversation(c.id, e);

    div.appendChild(pinBtn);
    if (c.characterAvatar) {
      const avatar = document.createElement('img');
      avatar.className = 'conv-avatar';
      avatar.src = c.characterAvatar;
      div.appendChild(avatar);
    }
    div.appendChild(title);
    div.appendChild(del);
    list.appendChild(div);
  });
  filterConversations();
}

// ============================================
// Sidebar Search
// ============================================
function filterConversations() {
  const searchEl = document.getElementById('sidebarSearch');
  const query = searchEl ? searchEl.value.toLowerCase() : '';
  const items = document.querySelectorAll('.conv-item');
  items.forEach(item => {
    const title = item.querySelector('.conv-title').textContent.toLowerCase();
    item.style.display = (!query || title.includes(query)) ? '' : 'none';
  });
  // Hide empty group headers
  document.querySelectorAll('.conv-group-header').forEach(header => {
    let next = header.nextElementSibling;
    let hasVisible = false;
    while (next && !next.classList.contains('conv-group-header')) {
      if (next.classList.contains('conv-item') && next.style.display !== 'none') hasVisible = true;
      next = next.nextElementSibling;
    }
    header.style.display = hasVisible ? '' : 'none';
  });
}

// ============================================
// Sidebar Toggle
// ============================================
function toggleSidebar() {
  const sb = document.getElementById('sidebar');
  const overlay = document.getElementById('sidebarOverlay');
  sb.classList.toggle('collapsed');
  overlay.classList.toggle('open', !sb.classList.contains('collapsed') && window.innerWidth <= 768);
}

// ============================================
// Toolbar Menu
// ============================================
function toggleToolbarMenu(e) {
  e.stopPropagation();
  document.getElementById('toolbarMenu').classList.toggle('open');
}
function closeToolbarMenu() {
  document.getElementById('toolbarMenu').classList.remove('open');
}
document.addEventListener('click', () => closeToolbarMenu());

// ============================================
// Setup & Settings
// ============================================
function getSelectedModel(target) {
  const manualEl = document.getElementById(target === 'setup' ? 'setupModelManual' : 'setModelManual');
  const selectEl = document.getElementById(target === 'setup' ? 'setupModelSelect' : 'setModelSelect');
  const manual = manualEl.value.trim();
  if (manual) return manual;
  return selectEl.value || 'gpt-4o';
}

function saveSetup() {
  let proxy = document.getElementById('setupProxy').value.trim();
  const key = document.getElementById('setupKey').value.trim();
  if (!proxy || !key) { showToast('Base URL and API Key are required.', 'error'); return; }
  proxy = proxy.replace(/\/(chat\/completions|messages)\/?$/, '');
  const model = getSelectedModel('setup');
  localStorage.setItem('llmProxyUrl', proxy);
  localStorage.setItem('llmApiKey', key);
  localStorage.setItem('llmModel', model);
  document.getElementById('setupModal').classList.remove('open');
  // Try to fetch models in the background
  fetchAvailableModels(proxy, key).then(models => {
    localStorage.setItem('llmModelList', JSON.stringify(models));
    loadCachedModels('settings');
  }).catch(() => {});
}

function openSettings() {
  document.getElementById('setProxy').value = localStorage.getItem('llmProxyUrl') || '';
  document.getElementById('setKey').value = localStorage.getItem('llmApiKey') || '';
  const currentModel = localStorage.getItem('llmModel') || '';
  document.getElementById('setModelManual').value = currentModel;
  document.getElementById('setApiFormat').value = localStorage.getItem('llmApiFormat') || 'auto';
  document.getElementById('setSystemPrompt').value = localStorage.getItem('llmSystemPrompt') || '';
  document.getElementById('setPersona').value = localStorage.getItem('llmPersona') || '';
  document.getElementById('setExtraParams').value = localStorage.getItem('llmExtraParams') || '';
  document.getElementById('setExcludeParams').value = localStorage.getItem('llmExcludeParams') || '';
  document.getElementById('setStreaming').checked = localStorage.getItem('llmStreaming') !== 'false';
  document.getElementById('setEnterSend').checked = localStorage.getItem('llmEnterSend') !== 'false';
  document.getElementById('setTemperature').value = localStorage.getItem('llmTemperature') || '';
  document.getElementById('setInputCost').value = localStorage.getItem('llmInputCost') || '';
  document.getElementById('setOutputCost').value = localStorage.getItem('llmOutputCost') || '';
  document.getElementById('setFont').value = localStorage.getItem('assistantFont') || '';
  document.getElementById('setWebSearch').checked = localStorage.getItem('llmWebSearch') === 'true';

  // Presets
  loadPresets();

  // Theme
  const currentTheme = localStorage.getItem('assistantTheme') || 'dark';
  document.getElementById('setTheme').value = currentTheme;
  document.getElementById('customThemeColors').style.display = currentTheme === 'custom' ? 'grid' : 'none';
  if (currentTheme === 'custom') loadCustomColorPickers();

  // Model select
  loadCachedModels('settings');
  const selectEl = document.getElementById('setModelSelect');
  if (currentModel) {
    for (const opt of selectEl.options) {
      if (opt.value === currentModel) { opt.selected = true; break; }
    }
  }

  document.getElementById('settingsModal').classList.add('open');
}

function saveSettings() {
  // Validate extra params JSON
  const extraParamsField = document.getElementById('setExtraParams');
  const extraParamsVal = extraParamsField.value.trim();
  if (extraParamsVal) {
    try {
      JSON.parse(extraParamsVal);
      extraParamsField.classList.remove('invalid');
    } catch(e) {
      extraParamsField.classList.add('invalid');
      showToast('Extra Parameters must be valid JSON.', 'error');
      return;
    }
  } else {
    extraParamsField.classList.remove('invalid');
  }

  let proxy = document.getElementById('setProxy').value.trim();
  proxy = proxy.replace(/\/(chat\/completions|messages)\/?$/, '');
  localStorage.setItem('llmProxyUrl', proxy);
  localStorage.setItem('llmApiKey', document.getElementById('setKey').value.trim());
  localStorage.setItem('llmModel', getSelectedModel('settings'));
  localStorage.setItem('llmApiFormat', document.getElementById('setApiFormat').value);
  localStorage.setItem('llmSystemPrompt', document.getElementById('setSystemPrompt').value.trim());
  localStorage.setItem('llmPersona', document.getElementById('setPersona').value.trim());
  localStorage.setItem('llmExtraParams', extraParamsVal);
  localStorage.setItem('llmExcludeParams', document.getElementById('setExcludeParams').value.trim());
  localStorage.setItem('llmStreaming', document.getElementById('setStreaming').checked ? 'true' : 'false');
  localStorage.setItem('llmEnterSend', document.getElementById('setEnterSend').checked ? 'true' : 'false');
  const tempVal = document.getElementById('setTemperature').value.trim();
  localStorage.setItem('llmTemperature', tempVal);
  localStorage.setItem('llmInputCost', document.getElementById('setInputCost').value.trim());
  localStorage.setItem('llmOutputCost', document.getElementById('setOutputCost').value.trim());
  localStorage.setItem('llmWebSearch', document.getElementById('setWebSearch').checked ? 'true' : 'false');

  // Theme
  const themeName = document.getElementById('setTheme').value;
  if (themeName === 'custom') {
    localStorage.setItem('assistantCustomTheme', JSON.stringify(getCustomThemeFromPickers()));
  }
  applyTheme(themeName);

  // Font
  const fontName = document.getElementById('setFont').value.trim();
  localStorage.setItem('assistantFont', fontName);
  loadCustomFont(fontName);

  // Try to fetch models in background
  const key = document.getElementById('setKey').value.trim();
  if (proxy && key) {
    fetchAvailableModels(proxy, key).then(models => {
      localStorage.setItem('llmModelList', JSON.stringify(models));
    }).catch(() => {});
  }

  document.getElementById('settingsModal').classList.remove('open');
}

function closeSettings() {
  document.getElementById('settingsModal').classList.remove('open');
  // Revert theme if user didn't save
  loadTheme();
}

// ============================================
// System Prompt Presets
// ============================================
function loadPresets() {
  let presets = [];
  try { presets = JSON.parse(localStorage.getItem('assistantPresets') || '[]'); } catch(e) {}
  const select = document.getElementById('setPresetSelect');
  select.innerHTML = '<option value="">-- Custom --</option>';
  presets.forEach(p => {
    const opt = document.createElement('option');
    opt.value = p.id;
    opt.textContent = p.name;
    select.appendChild(opt);
  });
  return presets;
}

function applyPreset(id) {
  if (!id) return;
  let presets = [];
  try { presets = JSON.parse(localStorage.getItem('assistantPresets') || '[]'); } catch(e) {}
  const preset = presets.find(p => p.id === id);
  if (!preset) return;
  document.getElementById('setSystemPrompt').value = preset.systemPrompt || '';
  document.getElementById('setPersona').value = preset.persona || '';
}

function saveCurrentAsPreset() {
  const name = prompt('Preset name:');
  if (!name) return;
  let presets = [];
  try { presets = JSON.parse(localStorage.getItem('assistantPresets') || '[]'); } catch(e) {}
  const preset = {
    id: 'preset_' + Date.now(),
    name: name,
    systemPrompt: document.getElementById('setSystemPrompt').value.trim(),
    persona: document.getElementById('setPersona').value.trim()
  };
  presets.push(preset);
  localStorage.setItem('assistantPresets', JSON.stringify(presets));
  loadPresets();
  document.getElementById('setPresetSelect').value = preset.id;
  showToast('Preset saved: ' + name, 'success');
}

function deleteSelectedPreset() {
  const select = document.getElementById('setPresetSelect');
  const id = select.value;
  if (!id) { showToast('Select a preset to delete.', 'info'); return; }
  let presets = [];
  try { presets = JSON.parse(localStorage.getItem('assistantPresets') || '[]'); } catch(e) {}
  const preset = presets.find(p => p.id === id);
  if (!preset) return;
  if (!confirm('Delete preset "' + preset.name + '"?')) return;
  presets = presets.filter(p => p.id !== id);
  localStorage.setItem('assistantPresets', JSON.stringify(presets));
  loadPresets();
  showToast('Preset deleted.', 'info');
}

// ============================================
// Render Messages
// ============================================
function renderMessages() {
  closeChatSearch();
  const area = document.getElementById('messagesArea');
  area.innerHTML = '';

  if (messages.length === 0) {
    area.innerHTML = '<div class="chat-placeholder">Start a conversation...</div>';
    return;
  }

  messages.forEach((msg, idx) => {
    if (msg._editing) {
      renderEditMode(area, msg, idx);
      return;
    }

    const wrapper = document.createElement('div');
    wrapper.className = 'msg-wrapper ' + msg.role;

    const bubble = document.createElement('div');
    bubble.className = 'msg-bubble ' + msg.role;

    if (msg.role === 'user') {
      if (Array.isArray(msg.content)) {
        msg.content.forEach(part => {
          if (part.type === 'text') {
            const sp = document.createElement('span');
            sp.textContent = part.text;
            bubble.appendChild(sp);
          } else if (part.type === 'image_url') {
            const img = document.createElement('img');
            img.src = part.image_url.url;
            img.className = 'chat-inline-img';
            bubble.appendChild(img);
          }
        });
      } else {
        bubble.textContent = msg.content;
      }
    } else if (msg.role === 'assistant') {
      const thinkData = msg.swipeThinking && msg.swipeThinking[msg.swipeIndex];
      const toolData = msg.swipeToolUse && msg.swipeToolUse[msg.swipeIndex];
      bubble.innerHTML = renderThinkingHTML(thinkData || '') + renderToolBlocksHTML(toolData || []) + renderMarkdown(msg.content);
      postRenderProcessing(bubble);
    } else {
      bubble.textContent = msg.content;
    }

    wrapper.appendChild(bubble);

    // Message actions
    const actions = document.createElement('div');
    actions.className = 'msg-actions';

    const copyBtn = document.createElement('button');
    copyBtn.className = 'msg-action-btn';
    copyBtn.textContent = 'Copy';
    copyBtn.onclick = () => {
      navigator.clipboard.writeText(getMsgText(msg));
      copyBtn.textContent = 'Copied!';
      setTimeout(() => copyBtn.textContent = 'Copy', 1500);
    };
    actions.appendChild(copyBtn);

    if (msg.role === 'user') {
      const editBtn = document.createElement('button');
      editBtn.className = 'msg-action-btn';
      editBtn.textContent = 'Edit';
      editBtn.onclick = () => { msg._editing = true; renderMessages(); };
      actions.appendChild(editBtn);

      const forkBtn = document.createElement('button');
      forkBtn.className = 'msg-action-btn';
      forkBtn.textContent = 'Fork';
      forkBtn.onclick = () => forkBranch(idx);
      actions.appendChild(forkBtn);
    }

    const delBtn = document.createElement('button');
    delBtn.className = 'msg-action-btn';
    delBtn.textContent = 'Delete';
    delBtn.onclick = () => {
      if (msg.role === 'assistant' && !confirm('Delete this response?')) return;
      messages.splice(idx, 1);
      saveConversations();
      renderMessages();
      updateTokenInfo();
    };
    actions.appendChild(delBtn);

    wrapper.appendChild(actions);

    // Branch controls for user messages
    if (msg.role === 'user' && msg.branches && msg.branches.length > 1) {
      const branchDiv = document.createElement('div');
      branchDiv.className = 'branch-controls has-branches';
      const bPrev = document.createElement('button');
      bPrev.textContent = '\u25C0';
      bPrev.disabled = msg.branchIndex <= 0;
      bPrev.onclick = () => switchBranch(idx, -1);
      const bCounter = document.createElement('span');
      bCounter.textContent = (msg.branchIndex + 1) + '/' + msg.branches.length;
      const bNext = document.createElement('button');
      bNext.textContent = '\u25B6';
      bNext.disabled = msg.branchIndex >= msg.branches.length - 1;
      bNext.onclick = () => switchBranch(idx, 1);
      branchDiv.appendChild(bPrev);
      branchDiv.appendChild(bCounter);
      branchDiv.appendChild(bNext);
      wrapper.appendChild(branchDiv);
    }

    if (msg.role === 'assistant') {
      // Swipe controls
      const swipeDiv = document.createElement('div');
      swipeDiv.className = 'swipe-controls' + (msg.swipes && msg.swipes.length > 1 ? ' has-swipes' : '');
      const prev = document.createElement('button');
      prev.textContent = '\u25C0';
      prev.disabled = !msg.swipes || msg.swipeIndex <= 0;
      prev.onclick = () => swipeMsg(idx, -1);
      const counter = document.createElement('span');
      counter.textContent = msg.swipes ? (msg.swipeIndex + 1) + '/' + msg.swipes.length : '1/1';
      const next = document.createElement('button');
      next.textContent = '\u25B6';
      next.disabled = !msg.swipes || msg.swipeIndex >= msg.swipes.length - 1;
      next.onclick = () => swipeMsg(idx, 1);
      swipeDiv.appendChild(prev);
      swipeDiv.appendChild(counter);
      swipeDiv.appendChild(next);
      wrapper.appendChild(swipeDiv);

      const regen = document.createElement('button');
      regen.className = 'regen-btn';
      regen.textContent = 'Regenerate';
      regen.onclick = () => regenerate();
      wrapper.appendChild(regen);
    }

    // Fade-in on last message only
    if (idx === messages.length - 1) wrapper.classList.add('msg-new');

    area.appendChild(wrapper);
  });

  area.scrollTop = area.scrollHeight;
}

function renderEditMode(area, msg, idx) {
  const wrapper = document.createElement('div');
  wrapper.className = 'msg-wrapper user';

  const ta = document.createElement('textarea');
  ta.className = 'msg-edit-textarea';
  ta.value = getMsgText(msg);
  wrapper.appendChild(ta);

  const editActions = document.createElement('div');
  editActions.className = 'msg-edit-actions';

  const cancelBtn = document.createElement('button');
  cancelBtn.className = 'msg-edit-cancel';
  cancelBtn.textContent = 'Cancel';
  cancelBtn.onclick = () => { delete msg._editing; renderMessages(); };

  const saveBtn = document.createElement('button');
  saveBtn.className = 'msg-edit-save';
  saveBtn.textContent = 'Save & Resend';
  saveBtn.onclick = async () => {
    const editedText = ta.value;
    delete msg._editing;

    // Save old branch before truncating (deep clone to prevent mutation)
    const oldBranch = JSON.parse(JSON.stringify(messages.slice(idx)));
    if (!msg.branches) {
      msg.branches = [oldBranch];
      msg.branchIndex = 1;
    } else {
      // Save current continuation as current branch before editing
      msg.branches[msg.branchIndex] = oldBranch;
      msg.branchIndex = msg.branches.length;
    }

    msg.content = editedText;
    messages.length = idx + 1;
    saveConversations();
    renderMessages();
    await resendAfterEdit();

    // Save new branch (after response)
    const newBranch = JSON.parse(JSON.stringify(messages.slice(idx)));
    msg.branches[msg.branchIndex] = newBranch;
    saveConversations();
    renderMessages();
  };

  editActions.appendChild(cancelBtn);
  editActions.appendChild(saveBtn);
  wrapper.appendChild(editActions);
  area.appendChild(wrapper);
}

async function resendAfterEdit() {
  const proxyUrl = localStorage.getItem('llmProxyUrl');
  const apiKey = localStorage.getItem('llmApiKey');
  const conv = getActiveConv();
  const systemPrompt = getConversationSystemPrompt(conv);
  const persona = localStorage.getItem('llmPersona') || '';
  if (!proxyUrl || !apiKey) return;

  const assistantMsg = { role: 'assistant', content: '', swipes: [''], swipeIndex: 0 };
  messages.push(assistantMsg);

  const area = document.getElementById('messagesArea');
  const wrapper = document.createElement('div');
  wrapper.className = 'msg-wrapper assistant';
  const bubble = document.createElement('div');
  bubble.className = 'msg-bubble assistant';
  bubble.innerHTML = '<div class="typing-dots"><span></span><span></span><span></span></div>';
  wrapper.appendChild(bubble);
  area.appendChild(wrapper);
  area.scrollTop = area.scrollHeight;

  const apiMessages = [{ role: 'system', content: systemPrompt }];
  if (persona) apiMessages.push({ role: 'system', content: 'About the user: ' + persona });
  messages.forEach(m => { if (m.role !== 'system') apiMessages.push({ role: m.role, content: m.content }); });

  await streamResponse(apiMessages, assistantMsg, 0, bubble);

  if (conv) conv.updatedAt = Date.now();
  saveConversations();
  renderMessages();
  updateTokenInfo();
}

// ============================================
// Swipe
// ============================================
function swipeMsg(idx, dir) {
  const msg = messages[idx];
  if (!msg || !msg.swipes) return;
  msg.swipeIndex = Math.max(0, Math.min(msg.swipes.length - 1, msg.swipeIndex + dir));
  msg.content = msg.swipes[msg.swipeIndex];
  saveConversations();
  renderMessages();
}

// ============================================
// Branch Switching
// ============================================
function switchBranch(msgIdx, dir) {
  const msg = messages[msgIdx];
  if (!msg || !msg.branches) return;
  // Save current continuation as the current branch (deep clone)
  msg.branches[msg.branchIndex] = JSON.parse(JSON.stringify(messages.slice(msgIdx)));
  // Switch
  const newIdx = Math.max(0, Math.min(msg.branches.length - 1, msg.branchIndex + dir));
  if (newIdx === msg.branchIndex) return;
  msg.branchIndex = newIdx;
  // Replace messages from msgIdx onward with the selected branch
  const branch = msg.branches[msg.branchIndex];
  messages.length = msgIdx;
  branch.forEach(m => messages.push(m));
  saveConversations();
  renderMessages();
  updateTokenInfo();
}

async function forkBranch(msgIdx) {
  if (streaming) return;
  const msg = messages[msgIdx];
  if (!msg || msg.role !== 'user') return;

  // Save current continuation as a branch (deep clone)
  const currentBranch = JSON.parse(JSON.stringify(messages.slice(msgIdx)));
  if (!msg.branches) {
    msg.branches = [currentBranch];
    msg.branchIndex = 1;
  } else {
    msg.branches[msg.branchIndex] = currentBranch;
    msg.branchIndex = msg.branches.length;
  }

  // Truncate messages after this user message and re-send
  messages.length = msgIdx + 1;
  saveConversations();
  renderMessages();
  await resendAfterEdit();

  // Save the new branch
  const newBranch = JSON.parse(JSON.stringify(messages.slice(msgIdx)));
  msg.branches[msg.branchIndex] = newBranch;
  saveConversations();
  renderMessages();
}

// ============================================
// Thinking/Reasoning Rendering
// ============================================
function renderThinkingHTML(text) {
  if (!text) return '';
  const escaped = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  return '<div class="thinking-block">' +
    '<div class="thinking-header" onclick="this.nextElementSibling.classList.toggle(\'open\');this.querySelector(\'.thinking-arrow\').textContent=this.nextElementSibling.classList.contains(\'open\')?\'\u25BE\':\'\u25B8\'">' +
    '\uD83D\uDCAD Thinking <span class="thinking-arrow">\u25B8</span></div>' +
    '<div class="thinking-content">' + escaped + '</div></div>';
}

// ============================================
// Tool Use Rendering
// ============================================
function renderToolBlocksHTML(toolBlocks) {
  if (!toolBlocks || toolBlocks.length === 0) return '';
  return toolBlocks.map((tb, i) => {
    const query = tb.query || '';
    const results = tb.results || [];
    const searching = tb.searching;
    if (searching) {
      return '<div class="tool-use-block"><div class="tool-use-header">\u{1F50D} Searching\u2026</div></div>';
    }
    const count = results.length;
    const resultsHTML = results.map(r => {
      const title = r.title || r.url || 'Result';
      const url = r.url || '#';
      const displayUrl = url.replace(/^https?:\/\//, '').replace(/\/+$/, '');
      return '<div class="tool-use-result"><a href="' + url.replace(/"/g, '&quot;') + '" target="_blank" rel="noopener">' +
        title.replace(/&/g, '&amp;').replace(/</g, '&lt;') + '</a>' +
        '<span class="tool-result-url">' + displayUrl.replace(/&/g, '&amp;').replace(/</g, '&lt;') + '</span></div>';
    }).join('');
    const headerText = '\u{1F50D} Searched "' + query.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;') + '" \u00B7 ' + count + ' result' + (count !== 1 ? 's' : '');
    return '<div class="tool-use-block">' +
      '<div class="tool-use-header" onclick="this.nextElementSibling.classList.toggle(\'open\');this.querySelector(\'.tool-use-arrow\').textContent=this.nextElementSibling.classList.contains(\'open\')?\'\u25BE\':\'\u25B8\'">' +
      headerText +
      ' <span class="tool-use-arrow">\u25B8</span></div>' +
      '<div class="tool-use-results">' + resultsHTML + '</div></div>';
  }).join('');
}

// ============================================
// Streaming
// ============================================
async function streamResponse(apiMessages, assistantMsg, swipeIdx, bubbleEl, overrideModel) {
  const baseUrl = (localStorage.getItem('llmProxyUrl') || '').replace(/\/+$/, '');
  const apiKey = localStorage.getItem('llmApiKey');
  const model = overrideModel || localStorage.getItem('llmModel') || 'gpt-4o';
  const format = detectApiFormat(model);

  // Extra params & excludes
  let extra = {};
  try { extra = JSON.parse(localStorage.getItem('llmExtraParams') || '{}'); } catch(e) {}
  const exclude = (localStorage.getItem('llmExcludeParams') || '').split(',').map(s => s.trim()).filter(Boolean);

  abortController = new AbortController();
  streaming = true;
  const btn = document.getElementById('sendBtn');
  btn.textContent = 'Stop';
  btn.classList.add('streaming');
  btn.disabled = false;

  let fullText = '';
  let thinkingText = '';
  let lastRender = 0;
  let toolBlocks = [];
  let currentBlockType = null;
  let inputJsonBuf = '';

  try {
    let url, headers, body;
    const useStream = localStorage.getItem('llmStreaming') !== 'false';

    if (format === 'anthropic') {
      url = baseUrl + '/messages';
      headers = {
        'Content-Type': 'application/json',
        'x-api-key': apiKey,
        'anthropic-version': '2023-06-01'
      };
      const prepared = prepareAnthropicMessages(apiMessages);
      body = { model, system: prepared.system, messages: prepared.messages, max_tokens: 4096, stream: useStream, ...extra };
      if (localStorage.getItem('llmWebSearch') === 'true') {
        body.tools = (body.tools || []).concat([{ type: 'web_search_20250305', name: 'web_search', max_uses: 5 }]);
      }
    } else {
      url = baseUrl + '/chat/completions';
      headers = {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + apiKey
      };
      body = { model, messages: apiMessages, stream: useStream, ...extra };
    }
    if (!('temperature' in body)) {
      const temp = parseFloat(localStorage.getItem('llmTemperature'));
      if (!isNaN(temp)) body.temperature = temp;
    }
    exclude.forEach(k => delete body[k]);

    const resp = await fetch(url, {
      method: 'POST',
      headers,
      body: JSON.stringify(body),
      signal: abortController.signal
    });

    if (!resp.ok) {
      let errText = '';
      try { errText = await resp.text(); } catch(e) {}
      throw new Error('API returned ' + resp.status + (errText ? ': ' + errText.slice(0, 200) : ''));
    }

    const ct = resp.headers.get('content-type') || '';

    if (ct.includes('application/json')) {
      const data = await resp.json();
      if (format === 'anthropic') {
        fullText = (data.content || []).filter(c => c.type === 'text').map(c => c.text).join('') || 'No response.';
        // Extract thinking blocks from non-streaming response
        thinkingText = (data.content || []).filter(c => c.type === 'thinking').map(c => c.thinking).join('');
        // Extract tool blocks from non-streaming response
        for (const block of (data.content || [])) {
          if (block.type === 'server_tool_use' && block.name === 'web_search') {
            toolBlocks.push({ query: block.input?.query || '', results: [], searching: false });
          } else if (block.type === 'web_search_tool_result') {
            const tb = toolBlocks[toolBlocks.length - 1] || { query: '', results: [], searching: false };
            if (!toolBlocks.length) toolBlocks.push(tb);
            tb.results = (block.content || []).filter(r => r.type === 'web_search_result').map(r => ({ title: r.title, url: r.url }));
            tb.searching = false;
          }
        }
      } else {
        fullText = data.choices?.[0]?.message?.content || 'No response.';
        thinkingText = data.choices?.[0]?.message?.reasoning_content || '';
      }
      assistantMsg.swipes[swipeIdx] = fullText;
      assistantMsg.content = fullText;
      if (thinkingText) {
        assistantMsg.swipeThinking = assistantMsg.swipeThinking || [];
        assistantMsg.swipeThinking[swipeIdx] = thinkingText;
      }
      if (toolBlocks.length > 0) {
        assistantMsg.swipeToolUse = assistantMsg.swipeToolUse || [];
        assistantMsg.swipeToolUse[swipeIdx] = toolBlocks;
      }
      bubbleEl.innerHTML = renderThinkingHTML(thinkingText) + renderToolBlocksHTML(toolBlocks) + renderMarkdown(fullText);
      postRenderProcessing(bubbleEl);
    } else {
      // SSE streaming
      const reader = resp.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          const trimmed = line.trim();

          if (format === 'anthropic') {
            if (!trimmed.startsWith('data:')) continue;
            const payload = trimmed.slice(5).trim();
            if (!payload) continue;
            try {
              const json = JSON.parse(payload);
              if (json.type === 'content_block_start') {
                const cb = json.content_block;
                if (cb && cb.type === 'server_tool_use') {
                  currentBlockType = 'server_tool_use';
                  inputJsonBuf = '';
                  toolBlocks.push({ query: '', results: [], searching: true });
                } else if (cb && cb.type === 'web_search_tool_result') {
                  currentBlockType = 'web_search_tool_result';
                  const tb = toolBlocks[toolBlocks.length - 1];
                  if (tb) {
                    tb.results = (cb.content || []).filter(r => r.type === 'web_search_result').map(r => ({ title: r.title, url: r.url }));
                    tb.searching = false;
                  }
                } else if (cb && cb.type === 'text') {
                  currentBlockType = 'text';
                } else if (cb && cb.type === 'thinking') {
                  currentBlockType = 'thinking';
                }
              } else if (json.type === 'content_block_delta') {
                if (json.delta?.type === 'text_delta' && json.delta?.text) {
                  fullText += json.delta.text;
                } else if (json.delta?.type === 'thinking_delta' && json.delta?.thinking) {
                  thinkingText += json.delta.thinking;
                } else if (json.delta?.type === 'input_json_delta' && json.delta?.partial_json) {
                  inputJsonBuf += json.delta.partial_json;
                }
              } else if (json.type === 'content_block_stop') {
                if (currentBlockType === 'server_tool_use' && inputJsonBuf) {
                  try {
                    const parsed = JSON.parse(inputJsonBuf);
                    const tb = toolBlocks[toolBlocks.length - 1];
                    if (tb && parsed.query) tb.query = parsed.query;
                  } catch(e) {}
                  inputJsonBuf = '';
                }
                currentBlockType = null;
              } else if (json.type === 'message_stop') {
                // done
              } else if (json.type === 'error') {
                throw new Error(json.error?.message || 'Anthropic API error');
              }
            } catch(e) { if (e.message && !e.message.startsWith('Unexpected')) throw e; }
          } else {
            // OpenAI format
            if (!trimmed.startsWith('data:')) continue;
            const payload = trimmed.slice(5).trim();
            if (payload === '[DONE]') continue;
            try {
              const json = JSON.parse(payload);
              const delta = json.choices?.[0]?.delta?.content;
              if (delta) fullText += delta;
              const reasoning = json.choices?.[0]?.delta?.reasoning_content;
              if (reasoning) thinkingText += reasoning;
            } catch(e) {}
          }
        }

        assistantMsg.swipes[swipeIdx] = fullText;
        assistantMsg.content = fullText;
        const now = Date.now();
        if (now - lastRender > 80) {
          bubbleEl.innerHTML = renderThinkingHTML(thinkingText) + renderToolBlocksHTML(toolBlocks) + renderMarkdown(fullText);
          document.getElementById('messagesArea').scrollTop = document.getElementById('messagesArea').scrollHeight;
          lastRender = now;
        }
      }
      if (thinkingText) {
        assistantMsg.swipeThinking = assistantMsg.swipeThinking || [];
        assistantMsg.swipeThinking[swipeIdx] = thinkingText;
      }
      if (toolBlocks.length > 0) {
        assistantMsg.swipeToolUse = assistantMsg.swipeToolUse || [];
        assistantMsg.swipeToolUse[swipeIdx] = toolBlocks;
      }
      bubbleEl.innerHTML = renderThinkingHTML(thinkingText) + renderToolBlocksHTML(toolBlocks) + renderMarkdown(fullText);
      postRenderProcessing(bubbleEl);
    }
  } catch (e) {
    if (e.name === 'AbortError') {
      if (!fullText) fullText = '(stopped)';
    } else {
      fullText = 'Error: ' + e.message;
    }
    assistantMsg.swipes[swipeIdx] = fullText;
    assistantMsg.content = fullText;
    if (thinkingText) {
      assistantMsg.swipeThinking = assistantMsg.swipeThinking || [];
      assistantMsg.swipeThinking[swipeIdx] = thinkingText;
    }
    if (toolBlocks.length > 0) {
      assistantMsg.swipeToolUse = assistantMsg.swipeToolUse || [];
      assistantMsg.swipeToolUse[swipeIdx] = toolBlocks;
    }
    bubbleEl.innerHTML = renderThinkingHTML(thinkingText) + renderToolBlocksHTML(toolBlocks) + renderMarkdown(fullText);
  } finally {
    streaming = false;
    abortController = null;
    btn.textContent = 'Send';
    btn.classList.remove('streaming');
    btn.disabled = false;
  }
}

// ============================================
// Send Message
// ============================================
async function sendMessage() {
  if (streaming && abortController) { abortController.abort(); return; }

  const input = document.getElementById('chatInput');
  const text = input.value.trim();
  if (!text && pendingImages.length === 0) return;

  const proxyUrl = localStorage.getItem('llmProxyUrl');
  const apiKey = localStorage.getItem('llmApiKey');
  const conv = getActiveConv();
  const systemPrompt = getConversationSystemPrompt(conv);
  const persona = localStorage.getItem('llmPersona') || '';

  if (!proxyUrl || !apiKey) {
    document.getElementById('setupModal').classList.add('open');
    return;
  }

  let userContent;
  if (pendingImages.length > 0) {
    userContent = [];
    if (text) userContent.push({ type: 'text', text });
    pendingImages.forEach(img => userContent.push({ type: 'image_url', image_url: { url: img } }));
    pendingImages = [];
    document.getElementById('imagePreview').innerHTML = '';
  } else {
    userContent = text;
  }

  messages.push({ role: 'user', content: userContent });
  input.value = '';
  input.style.height = 'auto';

  // Auto-title
  if (conv && conv.title === 'New Chat') {
    conv.title = (text || 'Image chat').slice(0, 40);
    renderSidebar();
  }

  renderMessages();

  const assistantMsg = { role: 'assistant', content: '', swipes: [''], swipeIndex: 0 };
  messages.push(assistantMsg);

  const area = document.getElementById('messagesArea');
  const wrapper = document.createElement('div');
  wrapper.className = 'msg-wrapper assistant';
  const bubble = document.createElement('div');
  bubble.className = 'msg-bubble assistant';
  bubble.innerHTML = '<div class="typing-dots"><span></span><span></span><span></span></div>';
  wrapper.appendChild(bubble);
  area.appendChild(wrapper);
  area.scrollTop = area.scrollHeight;

  const apiMessages = [{ role: 'system', content: systemPrompt }];
  if (persona) apiMessages.push({ role: 'system', content: 'About the user: ' + persona });
  messages.forEach(m => { if (m.role !== 'system') apiMessages.push({ role: m.role, content: m.content }); });

  // Capture and clear model override
  const overrideModel = modelOverride;
  clearModelOverride();

  await streamResponse(apiMessages, assistantMsg, 0, bubble, overrideModel);

  if (messages.length > 50) messages.splice(0, messages.length - 50);
  if (conv) conv.updatedAt = Date.now();
  saveConversations();
  renderMessages();
  updateTokenInfo();
}

// ============================================
// Regenerate
// ============================================
async function regenerate() {
  if (streaming) return;
  let lastIdx = -1;
  for (let i = messages.length - 1; i >= 0; i--) {
    if (messages[i].role === 'assistant') { lastIdx = i; break; }
  }
  if (lastIdx === -1) return;

  const msg = messages[lastIdx];
  if (!msg.swipes) msg.swipes = [msg.content];
  msg.swipes.push('');
  msg.swipeIndex = msg.swipes.length - 1;
  msg.content = '';
  renderMessages();

  const area = document.getElementById('messagesArea');
  const wrappers = area.querySelectorAll('.msg-wrapper.assistant');
  const lastWrapper = wrappers[wrappers.length - 1];
  const bubble = lastWrapper.querySelector('.msg-bubble');
  bubble.innerHTML = '<div class="typing-dots"><span></span><span></span><span></span></div>';

  const conv = getActiveConv();
  const systemPrompt = getConversationSystemPrompt(conv);
  const persona = localStorage.getItem('llmPersona') || '';
  const apiMessages = [{ role: 'system', content: systemPrompt }];
  if (persona) apiMessages.push({ role: 'system', content: 'About the user: ' + persona });
  for (let i = 0; i < lastIdx; i++) {
    if (messages[i].role !== 'system') apiMessages.push({ role: messages[i].role, content: messages[i].content });
  }

  await streamResponse(apiMessages, msg, msg.swipeIndex, bubble);

  if (conv) conv.updatedAt = Date.now();
  saveConversations();
  renderMessages();
  updateTokenInfo();
}

// ============================================
// Clear Chat
// ============================================
function clearChat() {
  const conv = getActiveConv();
  if (conv) {
    conv.messages = [];
    conv.title = 'New Chat';
    messages = conv.messages;
    saveConversations();
    renderSidebar();
  }
  renderMessages();
  updateTokenInfo();
}

// ============================================
// Export / Import
// ============================================
function exportConversation() {
  const conv = getActiveConv();
  if (!conv) return;
  const data = { title: conv.title, messages: conv.messages, model: localStorage.getItem('llmModel') || '', systemPrompt: localStorage.getItem('llmSystemPrompt') || '', exportedAt: new Date().toISOString() };
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = (conv.title || 'chat') + '.json';
  a.click();
  URL.revokeObjectURL(url);
}

function exportAllConversations() {
  const data = {
    conversations: conversations,
    exportedAt: new Date().toISOString(),
    settings: {
      model: localStorage.getItem('llmModel') || '',
      systemPrompt: localStorage.getItem('llmSystemPrompt') || '',
      persona: localStorage.getItem('llmPersona') || '',
      apiFormat: localStorage.getItem('llmApiFormat') || 'auto',
      theme: localStorage.getItem('assistantTheme') || 'dark',
      font: localStorage.getItem('assistantFont') || ''
    }
  };
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'assistant-export-' + new Date().toISOString().slice(0, 10) + '.json';
  a.click();
  URL.revokeObjectURL(url);
}

function importConversation(event) {
  const file = event.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const data = JSON.parse(e.target.result);
      if (!data.messages || !Array.isArray(data.messages)) throw new Error('Invalid format');
      const conv = { id: genId(), title: data.title || 'Imported Chat', messages: data.messages, createdAt: Date.now(), updatedAt: Date.now() };
      conv.messages.forEach(m => {
        if (m.role === 'assistant' && !m.swipes) { m.swipes = [m.content]; m.swipeIndex = 0; }
      });
      conversations.unshift(conv);
      activeConvId = conv.id;
      messages = conv.messages;
      saveConversations();
      renderSidebar();
      renderMessages();
      updateTokenInfo();
    } catch (err) { showToast('Error importing: ' + err.message, 'error'); }
  };
  reader.readAsText(file);
  event.target.value = '';
}

// ============================================
// Export as Markdown
// ============================================
function exportMarkdown() {
  const conv = getActiveConv();
  if (!conv || conv.messages.length === 0) { showToast('No messages to export.', 'info'); return; }
  let md = '# ' + conv.title + '\n\n';
  conv.messages.forEach(m => {
    if (m.role === 'user') {
      md += '## User\n\n';
      const text = getMsgText(m);
      if (Array.isArray(m.content)) {
        m.content.forEach(p => {
          if (p.type === 'text') md += p.text + '\n\n';
          else if (p.type === 'image_url') md += '_[Image attachment]_\n\n';
        });
      } else {
        md += text + '\n\n';
      }
    } else if (m.role === 'assistant') {
      md += '## Assistant\n\n' + (m.content || '') + '\n\n';
    }
  });
  const blob = new Blob([md], { type: 'text/markdown' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = (conv.title || 'chat') + '.md';
  a.click();
  URL.revokeObjectURL(a.href);
}

// ============================================
// Chat Search (Ctrl+F)
// ============================================
let chatSearchMatches = [];
let chatSearchIdx = -1;
let chatSearchDebounce = null;

function openChatSearch() {
  const bar = document.getElementById('chatSearchBar');
  bar.classList.add('open');
  document.getElementById('chatSearchInput').focus();
}

function closeChatSearch() {
  const bar = document.getElementById('chatSearchBar');
  bar.classList.remove('open');
  document.getElementById('chatSearchInput').value = '';
  document.getElementById('chatSearchCount').textContent = '';
  clearChatHighlights();
  chatSearchMatches = [];
  chatSearchIdx = -1;
}

function clearChatHighlights() {
  document.querySelectorAll('.search-highlight').forEach(el => {
    const parent = el.parentNode;
    parent.replaceChild(document.createTextNode(el.textContent), el);
    parent.normalize();
  });
}

function debouncedChatSearch() {
  clearTimeout(chatSearchDebounce);
  chatSearchDebounce = setTimeout(performChatSearch, 200);
}

function performChatSearch() {
  clearChatHighlights();
  chatSearchMatches = [];
  chatSearchIdx = -1;
  const query = document.getElementById('chatSearchInput').value.trim();
  if (!query) { document.getElementById('chatSearchCount').textContent = ''; return; }

  const area = document.getElementById('messagesArea');
  const walker = document.createTreeWalker(area, NodeFilter.SHOW_TEXT, null, false);
  const textNodes = [];
  while (walker.nextNode()) textNodes.push(walker.currentNode);

  const lowerQuery = query.toLowerCase();
  textNodes.forEach(node => {
    const text = node.textContent;
    const lower = text.toLowerCase();
    let idx = lower.indexOf(lowerQuery);
    if (idx === -1) return;
    const frag = document.createDocumentFragment();
    let lastIdx = 0;
    while (idx !== -1) {
      if (idx > lastIdx) frag.appendChild(document.createTextNode(text.slice(lastIdx, idx)));
      const span = document.createElement('span');
      span.className = 'search-highlight';
      span.textContent = text.slice(idx, idx + query.length);
      frag.appendChild(span);
      chatSearchMatches.push(span);
      lastIdx = idx + query.length;
      idx = lower.indexOf(lowerQuery, lastIdx);
    }
    if (lastIdx < text.length) frag.appendChild(document.createTextNode(text.slice(lastIdx)));
    node.parentNode.replaceChild(frag, node);
  });

  document.getElementById('chatSearchCount').textContent = chatSearchMatches.length + ' matches';
  if (chatSearchMatches.length > 0) {
    chatSearchIdx = 0;
    chatSearchMatches[0].classList.add('active');
    chatSearchMatches[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
  }
}

function navigateChatSearch(dir) {
  if (chatSearchMatches.length === 0) return;
  chatSearchMatches[chatSearchIdx]?.classList.remove('active');
  chatSearchIdx = (chatSearchIdx + dir + chatSearchMatches.length) % chatSearchMatches.length;
  chatSearchMatches[chatSearchIdx].classList.add('active');
  chatSearchMatches[chatSearchIdx].scrollIntoView({ behavior: 'smooth', block: 'center' });
  document.getElementById('chatSearchCount').textContent = (chatSearchIdx + 1) + '/' + chatSearchMatches.length;
}

// ============================================
// Image Attachments
// ============================================
function readImageFile(file) {
  const reader = new FileReader();
  reader.onload = (e) => { pendingImages.push(e.target.result); renderPreviews(); };
  reader.readAsDataURL(file);
}

function handleFileSelect(event) {
  Array.from(event.target.files).filter(f => f.type.startsWith('image/')).forEach(readImageFile);
  event.target.value = '';
}

function renderPreviews() {
  const container = document.getElementById('imagePreview');
  container.innerHTML = '';
  pendingImages.forEach((img, idx) => {
    const thumb = document.createElement('div');
    thumb.className = 'img-thumb';
    const imgEl = document.createElement('img');
    imgEl.src = img;
    const rm = document.createElement('button');
    rm.className = 'remove-thumb';
    rm.innerHTML = '&times;';
    rm.onclick = () => { pendingImages.splice(idx, 1); renderPreviews(); };
    thumb.appendChild(imgEl);
    thumb.appendChild(rm);
    container.appendChild(thumb);
  });
}

// ============================================
// @Model Mentions
// ============================================
function clearModelOverride() {
  modelOverride = null;
  document.getElementById('modelOverrideBadge').classList.remove('visible');
}

function setModelOverride(model) {
  modelOverride = model;
  document.getElementById('modelOverrideText').textContent = model;
  document.getElementById('modelOverrideBadge').classList.add('visible');
  closeMentionDropdown();
}

function closeMentionDropdown() {
  document.getElementById('mentionDropdown').classList.remove('open');
  mentionActive = false;
  mentionIdx = 0;
}

function handleMentionInput(ta) {
  const val = ta.value;
  const cursorPos = ta.selectionStart;
  // Find @query before cursor
  const before = val.slice(0, cursorPos);
  const atMatch = before.match(/@([\w\-./]*)$/);
  if (!atMatch) { closeMentionDropdown(); return; }

  const query = atMatch[1].toLowerCase();
  let models = [];
  try { models = JSON.parse(localStorage.getItem('llmModelList') || '[]'); } catch(e) {}
  if (models.length === 0) { closeMentionDropdown(); return; }

  const filtered = models.filter(m => m.toLowerCase().includes(query)).slice(0, 8);
  if (filtered.length === 0) { closeMentionDropdown(); return; }

  const dropdown = document.getElementById('mentionDropdown');
  dropdown.innerHTML = '';
  mentionIdx = 0;
  filtered.forEach((m, i) => {
    const div = document.createElement('div');
    div.className = 'mention-item' + (i === 0 ? ' active' : '');
    div.textContent = m;
    div.onclick = () => selectMention(ta, m, atMatch.index);
    dropdown.appendChild(div);
  });
  dropdown.classList.add('open');
  mentionActive = true;
}

function selectMention(ta, model, atStart) {
  // Remove @query from input
  const after = ta.value.slice(ta.selectionStart);
  ta.value = ta.value.slice(0, atStart) + after;
  ta.focus();
  setModelOverride(model);
}

function handleMentionKeydown(e, ta) {
  if (!mentionActive) return;
  const dropdown = document.getElementById('mentionDropdown');
  const items = dropdown.querySelectorAll('.mention-item');
  if (items.length === 0) return;

  if (e.key === 'ArrowDown') {
    e.preventDefault();
    items[mentionIdx]?.classList.remove('active');
    mentionIdx = (mentionIdx + 1) % items.length;
    items[mentionIdx]?.classList.add('active');
    items[mentionIdx]?.scrollIntoView({ block: 'nearest' });
  } else if (e.key === 'ArrowUp') {
    e.preventDefault();
    items[mentionIdx]?.classList.remove('active');
    mentionIdx = (mentionIdx - 1 + items.length) % items.length;
    items[mentionIdx]?.classList.add('active');
    items[mentionIdx]?.scrollIntoView({ block: 'nearest' });
  } else if (e.key === 'Enter' || e.key === 'Tab') {
    e.preventDefault();
    e.stopPropagation();
    const model = items[mentionIdx]?.textContent;
    if (model) {
      const before = ta.value.slice(0, ta.selectionStart);
      const atMatch = before.match(/@([\w\-./]*)$/);
      if (atMatch) selectMention(ta, model, atMatch.index);
    }
  } else if (e.key === 'Escape') {
    closeMentionDropdown();
  }
}

// ============================================
// Character Card Import (PNG + JSON)
// ============================================
function extractCharaFromPNG(arrayBuffer) {
  const view = new DataView(arrayBuffer);
  let offset = 8; // skip PNG signature
  while (offset < view.byteLength) {
    const len = view.getUint32(offset);
    const typeBytes = new Uint8Array(arrayBuffer, offset + 4, 4);
    const type = String.fromCharCode(...typeBytes);
    if (type === 'tEXt') {
      const data = new Uint8Array(arrayBuffer, offset + 8, len);
      const nullIdx = data.indexOf(0);
      const keyword = new TextDecoder().decode(data.slice(0, nullIdx));
      if (keyword === 'chara') {
        const text = new TextDecoder().decode(data.slice(nullIdx + 1));
        return JSON.parse(atob(text));
      }
    }
    offset += 12 + len; // 4 length + 4 type + data + 4 CRC
  }
  return null;
}

function normalizeCharaCard(raw) {
  // V2 format wraps in { spec, data }
  if (raw.spec === 'chara_card_v2' && raw.data) return raw.data;
  // V1 is flat
  if (raw.name || raw.description || raw.first_mes) return raw;
  return raw;
}

function buildCharaSystemPrompt(card) {
  let parts = [];
  if (card.system_prompt) {
    parts.push(card.system_prompt);
  }
  if (card.name) parts.push('Character: ' + card.name);
  if (card.description) parts.push(card.description);
  if (card.personality) parts.push('Personality: ' + card.personality);
  if (card.scenario) parts.push('Scenario: ' + card.scenario);
  if (card.mes_example) parts.push('Example dialogue:\n' + card.mes_example);
  return parts.join('\n\n');
}

async function importCharacterCard(event) {
  const file = event.target.files[0];
  if (!file) return;
  event.target.value = '';

  try {
    let rawCard = null;
    let avatarDataUrl = null;

    if (file.name.toLowerCase().endsWith('.png')) {
      const arrayBuffer = await file.arrayBuffer();
      rawCard = extractCharaFromPNG(arrayBuffer);
      if (!rawCard) { showToast('No character data found in PNG.', 'error'); return; }
      // Also store the PNG as avatar
      const blob = new Blob([arrayBuffer], { type: 'image/png' });
      avatarDataUrl = await new Promise(resolve => {
        const reader = new FileReader();
        reader.onload = e => resolve(e.target.result);
        reader.readAsDataURL(blob);
      });
    } else if (file.name.toLowerCase().endsWith('.json')) {
      const text = await file.text();
      rawCard = JSON.parse(text);
    } else {
      showToast('Unsupported file type. Use .png or .json.', 'error');
      return;
    }

    const card = normalizeCharaCard(rawCard);
    const charName = card.name || 'Character';
    const systemPrompt = buildCharaSystemPrompt(card);

    // Create a new conversation
    const conv = {
      id: genId(),
      title: charName,
      messages: [],
      createdAt: Date.now(),
      updatedAt: Date.now(),
      characterCard: card,
      characterSystemPrompt: systemPrompt
    };

    if (avatarDataUrl) conv.characterAvatar = avatarDataUrl;

    // Add first message if present
    if (card.first_mes) {
      conv.messages.push({
        role: 'assistant',
        content: card.first_mes,
        swipes: [card.first_mes],
        swipeIndex: 0
      });
    }

    conversations.unshift(conv);
    activeConvId = conv.id;
    messages = conv.messages;
    saveConversations();
    renderSidebar();
    renderMessages();
    updateTokenInfo();
    updateCharacterUI();

    showToast('Character imported: ' + charName, 'success');
    if (window.innerWidth <= 768) toggleSidebar();
  } catch (err) {
    showToast('Error importing character: ' + err.message, 'error');
  }
}

function getConversationSystemPrompt(conv) {
  if (conv && conv.characterSystemPrompt) return conv.characterSystemPrompt;
  return localStorage.getItem('llmSystemPrompt') || 'You are a helpful assistant.';
}

function updateCharacterUI() {
  const conv = getActiveConv();
  const infoBtn = document.getElementById('charInfoBtn');
  const titleEl = document.querySelector('.toolbar-title');
  if (conv && conv.characterCard) {
    infoBtn.style.display = '';
    titleEl.textContent = conv.characterCard.name || conv.title;
  } else {
    infoBtn.style.display = 'none';
    titleEl.textContent = 'AI Assistant';
  }
}

function showCharacterInfo() {
  const conv = getActiveConv();
  if (!conv || !conv.characterCard) return;
  const card = conv.characterCard;

  // Remove existing popup
  document.querySelectorAll('.char-info-overlay,.char-info-popup').forEach(el => el.remove());

  const overlay = document.createElement('div');
  overlay.className = 'char-info-overlay';
  overlay.onclick = () => { overlay.remove(); popup.remove(); };

  const popup = document.createElement('div');
  popup.className = 'char-info-popup';

  let html = '';
  if (conv.characterAvatar) {
    html += '<img class="char-info-avatar" src="' + conv.characterAvatar.replace(/"/g, '&quot;') + '">';
  }
  html += '<h3>' + (card.name || 'Character').replace(/&/g, '&amp;').replace(/</g, '&lt;') + '</h3>';

  const fields = [
    ['Description', card.description],
    ['Personality', card.personality],
    ['Scenario', card.scenario],
    ['First Message', card.first_mes],
    ['System Prompt', card.system_prompt],
    ['Example Dialogue', card.mes_example],
    ['Creator Notes', card.creator_notes]
  ];
  fields.forEach(([label, value]) => {
    if (!value) return;
    html += '<div class="char-info-field"><div class="char-info-label">' + label + '</div>' +
      '<div class="char-info-value">' + value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</div></div>';
  });

  html += '<button class="btn btn-primary" style="margin-top:12px;width:100%" onclick="this.parentElement.previousElementSibling.click()">Close</button>';
  popup.innerHTML = html;

  document.body.appendChild(overlay);
  document.body.appendChild(popup);
}

// ============================================
// Voice Input
// ============================================
function toggleVoice() {
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SR) return;
  const btn = document.getElementById('voiceBtn');

  if (voiceRec) {
    voiceRec.stop();
    voiceRec = null;
    btn.classList.remove('recording');
    return;
  }

  voiceRec = new SR();
  voiceRec.lang = 'en-US';
  voiceRec.interimResults = true;
  voiceRec.continuous = true;

  const input = document.getElementById('chatInput');
  const startText = input.value;
  btn.classList.add('recording');

  voiceRec.onresult = (e) => {
    let transcript = '';
    for (let i = 0; i < e.results.length; i++) transcript += e.results[i][0].transcript;
    input.value = startText + transcript;
    input.style.height = 'auto';
    input.style.height = Math.min(input.scrollHeight, 150) + 'px';
  };

  voiceRec.onend = () => { btn.classList.remove('recording'); voiceRec = null; };
  voiceRec.onerror = () => { btn.classList.remove('recording'); voiceRec = null; };
  voiceRec.start();
}
</script>
</body>
</html>
